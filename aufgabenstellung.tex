\clearpage
\section{Einf{\"{u}}hrung}
\begin{figure}
	\centering
	\includevisio[width=\textwidth]{simulation}
	\caption{Screenshot der Simulation}
	\label{fig:simulation}
\end{figure}

Diese Bachelorarbeit besteht aus drei Teilen. Im ersten wird das zu l{\"{o}}sende Problem-- die Entwicklung eines
Simulationswerkzeuges, das als {\"{U}}bungsaufgabe fungiert, zum Modul "Ausfallsichere Systeme" -- entfaltet,
im zweiten auf die dazu ben{\"{o}}tigten Grundlagen eingegangen und als letztes wird der L{\"{o}}sungsweg 
skizziert. 

Der erste Teil besteht aus einer Darlegung des Problems, um den Sinn und Zweck dieser Arbeit zu verdeutlichen. 
Danach wird erkl{\"{a}}rt, warum die bislang an der FH S{\"{u}}dwestfalen existierende {\"{U}}bungsaufgabe nicht optimal ist.
Basierend auf dieser Analyse werden die Anforderungen an die neue Aufgabe entwickelt. 

Im zweiten Teil werden als erstes die ben{\"{o}}tigten Grundlagen zur Umsetzung erkl{\"{a}}rt. Dabei geht es einerseits um 
mechanische und physische Konzepte wie das \textit{differential steering} und auch um informationstechnologische Aspekte
wie die Serialisierung von Daten oder verschiedene Netzwerkkommunikationsarten.

Darauf aufbauend wird dann im dritten Teil die Implementierung beschrieben, mit besonderem Fokus auf dem 
Fehlermodell und der Fehlerinjektion. Zum Schluss wird die Simulation anhand der Kriterien evaluiert und ein Fazit 
gezogen.

\subsection{Motivation}
Seit der Einf{\"{u}}hrung der Computer und vor allem seit dem rasanten Wachstums des Internets, werden Computer in immer 
mehr Bereichen eingesetzt. Das betrifft nicht nur die eigentlichen "Personal-Computer" auf dem Schreibtisch, 
sondern mehr und mehr embedded systems, die f{\"{u}}r viele Laien gar nicht als "Computer" wahrgenommen werden. Diese 
als "Digitalisierung" beschriebene Tendenz der Gegenwart hat neben der Berufswelt l{\"{a}}ngst auch weite Bereiche 
der Freizeitaktivit{\"{a}}ten erfasst -- in Bowlingbahnen beispielsweise z{\"{a}}hlt ein Computer f{\"{u}}r jeden 
Spieler mit, wie viele Punkte erreicht wurden und stellt die umgeworfenen Pins automatisch wieder auf. All dies 
bietet enorme, jeden Tag ersichtlich werdende Vorteile, birgt jedoch auch Risiken. 

Denn durch die steigende Komplexit{\"{a}}t der Hard- und Software wird das System fehleranf{\"{a}}lliger. Es gibt 
mehr Komponenten, also kann mehr kaputt gehen. Letztlich ist es nicht m{\"{o}}glich, in hochkomplexen Systemen ein 
absolut perfektes, v{\"{o}}llig fehlerfreies System zu entwickeln. 
Was bei einem Bowlingabend f{\"{u}}r die Mitspieler nicht besonders kritisch ist, wird zu einem Problem,in unmittelbar 
lebenswichtigen Bereichen wie der Strom- und Wasserversorgung, Fahrassistenz und {\"{a}}hnlichem. Auch kleine 
Fehler dort k{\"{o}}nnen enorme Konsequenzen haben. Ein tragisches Beispiel ist der Therac-25, eine Maschine zur 
Strahlentherapie. Durch verschiedene Softwarefehler kam es unter bestimmten Umst{\"{a}}nden zu {\"{u}}berh{\"{o}}hten 
Strahlendosen, die teilweise t{\"{o}}dlich endeten.

Aus dem bislang Festgestellten ergibt sich die zwingende Notwendigkeit, Hard- und Software gr{\"{u}}ndlich zu 
testen. Es gibt verschiedene Arten von Tests und Teststrategien, die das System aus unterschiedlichen Blickwinkeln 
betrachten. Hierbei kann, zum Beispiel, zwischen static und dynamic testing unterschieden werden. 

Bei statischem Testen wird der Quellcode untersucht, das Programm oder  Programmbestandteile aber nicht 
ausgef{\"{u}}hrt. Ein Beispiel daf{\"{u}}r ist static analysis, bei der der Programmcode auf auf{\"{a}}llige
Codekonstrukte untersucht wird, die h{\"{a}}ufig zu Fehlern f{\"{u}}hren -- wie zum Beispiel die Benutzung nicht 
initialisierter Variablen. 

Ein anderer Ansatz sind die code reviews, bei denen der programmierte Code mit weiteren Programmieren besprochen 
wird, um nach dem Vier-Augen-Prinzip weitere Probleme zu identifizieren.

Ein Beispiel f{\"{u}}r das dynamische Testen sind Unit-Tests, bei denen eine logische Einheit des Systems isoliert 
getestet wird, in dem sie mit vorher festgelegten Parametern ausgef{\"{u}}hrt wird und das Ergebnis mit einem 
erwarteten Ergebnis verglichen wird. Zum Beispiel k{\"{o}}nnen bei einem Navigationsger{\"{a}}t die Wegfindung, die 
Anzeige und das Interpretieren der Kartendaten als eigene Module programmiert und getestet werden. Um die 
Wegfindung zu testen, w{\"{u}}rde dann eine k{\"{u}}nstliche Karte genutzt und getestet, ob der 
Wegfindungsalgorithmus f{\"{u}}r vorher definierte Strecken auf dieser Karte die k{\"{u}}rzesten Wege findet. 

Es gibt allerdings auch F{\"{a}}lle, in denen es nicht machbar ist das System komplett durchzutesten. 
Beispielsweise ist es zwar mit spezieller Hardware m{\"{o}}glich, den Befehlssatz einer CPU zu emulieren und zu 
{\"{u}}berpr{\"{u}}fen, ob bestimmte Befehlskombinationen zu Problemen f{\"{u}}hren. Allerdings ist die 
Geschwindigkeit der Tests um mehrere Gr{\"{o}}ssenordnungen kleiner als die der tats{\"{a}}chlichen CPU, so das 
eine einzige x86 CPU in der ersten Sekunde mehr Instruktionen ausf{\"{u}}hrt als w{\"{a}}hrend des gesamten 
Testzyklus \cite{kaplan}. Es ist also unm{\"{o}}glich die CPU komplett durchzutesten, was dazu f{\"{u}}hrt das CPUs 
trotzdem noch Fehler enthalten, ein ber{\"{u}}hmtes Beispiel ist der Pentium F00F Bug.

Da also Testen alleine nicht ausreicht ist es besonders wichtig bei der Designphase angefangen die Ausfallsicherheit immer einzuplanen. Daf{\"{u}}r
muss ein Problembewusstsein geschaffen werden. Um dann wirklich ausfallsichere System zu entwickeln braucht man nat{\"{u}}rlich auch bestimmte Kentnisse 
{\"{u}}ber das Design und die Entwicklung solcher.

\subsection{Aufgabenstellung} 
Diese Kenntnisse zu vermitteln ist die Aufgabe des Moduls "Ausfallsichere Systeme" im Rahmen des Studienganges 
"Technische Informatik". Daf{\"{u}}r gibt es einen theoretischen (die Vorlesung) und einen praktischen Teil (eine 
{\"{U}}bungsaufgabe). Die {\"{U}}bungsaufgabe soll eine M{\"{o}}glichkeit geben, das in der Vorlesung erworbene 
theoretische Wissen anzuwenden. Dabei werden die Studierenden aus den gelernten Techniken die richtigen 
f{\"{u}}r die Aufgabe heraussuchen m{\"{u}}ssen, diese gegen Alternativen abw{\"{a}}gen und sie dann zu 
implementieren. Durch die  praktische Anwendung wird das Gelernte wiederholt und vertieft, was zu einem besseren 
Verst{\"{a}}ndnis f{\"{u}}hrt. 

Die Aufgabe dieser Bachelorarbeit ist die Konzeption einer solchen praktischen {\"{U}}bungsaufgabe. 
Zus{\"{a}}tzlich soll das fertige Produkt auch im Rahmen von Informationsveranstaltungen als Demonstrationsprojekt 
nutzbar sein. Damit soll auch Menschen ohne Fachkenntnisse ein interessanter Einblick in die 
Komplexit{\"{a}}t ausfallsicherer Systeme gegeben werden.

\subsection{Die ausfallsichere Heizung}\label{heizung}
Eine {\"{U}}bungsaufgabe im Module Ausfallsichere System wurde im Sommersemester 2016 an der FH S{\"{u}}dwestfalen entwickelt. Das Ziel war es, mithilfe zwei von Heizk{\"{o}}rpern, zweier
L{\"{u}}fter, einer Klappe und mehrer Temperatursensoren eine Temperatur zu regeln. F{\"{u}}r die Regelung m{\"{u}}ssen sich drei Rechner abstimmen, denn einer kontrolliert
beide Heizungen, einer beide L{\"{u}}fter und der dritte die Klappe. Um sich abzustimmen k{\"{o}}nnen die Rechner {\"{u}}ber UDP und I\textsuperscript{2}C miteinander kommunizieren.

Das Gesamtsystem ist Y-f{\"{o}}rmig aufgebaut; an den Armen des Ypsilon befindet sich jeweils ein Heizk{\"{o}}rper und ein L{\"{u}}fter; an dem Punkt, an dem sich
die Arme treffen, ist die Klappe, die den Luftstrom eines Arms ganz oder teilweise blockieren kann (diese Luft wird dann nach oben abgeleitet).

Um die Temperaturen in den Armen und die Temperatur des Luftstromes zu messen gibt es Temperatursensoren. Jeweils ein Temperatursensor im Luftausgangsstrom ist einem
der Rechner zugeordnet. Zus{\"{a}}tzlich hat der L{\"{u}}ftungsrechner einen Temperatursensor pro Arm zwischen L{\"{u}}fter und Heizung, und der Heizungsrechner jeweils
einen Temperatursensor vor der Heizung.

\begin{figure}
	\centering
	\includevisio[width=\textwidth]{HeizungHW}
	\caption{Aktoren und Sensoren der Heizung}
	\label{fig:heizunghw}
\end{figure}

All diese Bestandteile k{\"{o}}nnen auf verschiedene Arten fehlerhaft sein. Die Aufgabe der Studierenden
ist es, sich f{\"{u}}r die verschiedenen Fehlerkombinationen
geeignete Strategien auszudenken, um die Auswirkungen zu minimieren.

Beispielsweise kann es vorkommen das ein Heizk{\"{o}}rper ausf{\"{a}}llt, beziehungsweise dass dem
Heizk{\"{o}}rper ein Fehler injiziert wird\footnote{In diesem Fall wird die Stromversorgung gekappt},
also sich nicht weiter aufheizen kann. Dies muss erst einmal erkannt werden, zum Beispiel
durch den Vergleich des Sollwertes der Heizungsansteuerung und den Lufttemperaturen vor und hinter der Heizk{\"{o}}rper. Falls diese Temperaturen gleich sind,
wurde die Luft die vom L{\"{u}}fter Richtung Ausgang bewegt wurde, nicht aufgew{\"{a}}rmt, ergo heizt dieser Heizk{\"{o}}rper nicht. Dann k{\"{o}}nnen sich die
Rechner abstimmen, wie sie die Temperatur trotzdem ansteigen lassen k{\"{o}}nnen, zum Beispiel ob der {\"{u}}brig gebliene Heizk{\"{o}}rper st{\"{a}}rker heizen
soll, oder ob dieser weniger gek{\"{u}}hlt werden soll.

{\"{A}}hnlich ist es bei einem Ausfall der L{\"{u}}fter. 

Um die Kommunikation zu testen, k{\"{o}}nnen auch die Kommunikationswege ausfallen\footnote{Hierbei
wird das LAN-Kabel aus dem Switch gezogen, wodurch dieser Rechner keine Verbindung mehr zu den anderen hat.
Das gleiche gilt f{\"{u}}r die I\textsuperscript{2}C Leitungen}.
Was passiert, wenn der Heizungsrechner nicht mehr erreichbar ist, aber eine Heizung weniger stark heizen soll?
Da es zwei Kommunikationswege gibt, kann normalerweise UDP/IP f{\"{u}}r die Kommunikation verwendt werden
und I\textsuperscript{2}C nur als \textit{hot standby}. Alternativ wird ein {\"{U}}bertragungsweg nur
f{\"{u}}r Daten genutzt und der andere um zu signalisieren, dass dieser Rechner noch das
Steuerprogramm ausf{\"{u}}hrt. Der Ausfall einer der beiden Leitung kann anhand der Aktivit{\"{a}}t auf der
anderen erkannt werden.

Als letztes k{\"{o}}nnen auch die Temperatursensoren ausfallen. Im Luftausgangsstrom, wo drei Sensoren 
nebeneinander angeordnet sind, ist es m{\"{o}}glich den
Ausfall eines Sensors anhand der Diskrepanz der Messergebnisse aller Sensoren zu erkennen. Eine m{\"{o}}gliche 
Strategie, um die Ausgangstemperatur zu
bestimmen, w{\"{a}}re also, die \textit{triple modular redudancy} auszunutzen und den Mittelwert aller nicht klar als 
fehlerhaft erkennbaren Sensoren zu bilden.
Es ist auch denkbar, die vorherigen Messwerte zu benutzen um anhand unrealistischer Spr{\"{u}}nge der Messwerte zu 
erkennen, dass ein Sensor einen fehlerhaften Messwert geliefert hat.

Nat{\"{u}}rlich ist es auch denkbar, dass mehrere dieser Fehler auftreten, also beispielsweise f{\"{a}}llt
erst ein Sensor, dann das Netzwerk aus und danach steckt die Klappe fest.
Gerade bei Doppelfehlern, in denen eine L{\"{u}}ftung und ein Heizk{\"{o}}rper in unterschiedlichen {\"{A}}rmen 
ausfallen, gibt es die Gefahr, dass sich ein Arm {\"{u}}berhitzt und besch{\"{a}}digt wird.

\subsection{Diskussion}
Diese bestehende {\"{U}}bungsaufgabe hat allerdings einige Probleme, welche bei Konzeption und Bau einer neuen
{\"{U}}bungsaufgabe vermieden werden sollen.
\todo{was stoert was kann besser sein}

Weil die Heizungen eine beschr{\"{a}}nkte Leistung haben und eine gro{\ss}e Menge Luft 
($ \approx (13*13*55)cm^3$) aufheizen m{\"{u}}ssen, ist die Regelung sehr tr{\"{a}}ge. Damit ist es als
Vorf{\"{u}}hrobjekt zum Beispiel f{\"{u}}r Schulklassen ungeeignet, diese k{\"{o}}nnen nicht 10 Minuten warten
bis die Temperatur eingeregelt wurde, dann ein Fehler injiziert wurde (zum Beispiel eine Heizung
ausf{\"{a}}llt), dieser Ausfall erkannt wird und dann gegengesteuert wurde. Bei einer neuen {\"{U}}bungsaufgabe
soll das System schneller reagieren, am besten sogar instantan.

Desweiteren gibt es dieses System nur einmal. Das bedeutet einerseits, dass es bei gro{\ss}en Gruppen
an Sch{\"{u}}lern unm{\"{o}}glich wird, dass alle etwas f{\"{u}}hlen k{\"{o}}nnen und andererseits, es durch
die lange Regelzeit zu Koordinationsproblemen kommt. W{\"{a}}hrend eine Gruppe ihr Programm testet, m{\"{u}}ssen
alle anderen Gruppen warten. Da fast jeder Test mehrere Minuten dauert, verbringen die Gruppen die
allermeiste Zeit mit warten und nur wenig Zeit mit produktiver Arbeit. Um dies zu vermeiden w{\"{a}}hre es
hilfreich wenn die Ersatz{\"{u}}bungsaufgabe gleichzeitig von mehreren Teams unabh{\"{a}}nig voneinander bearbeitet
werden k{\"{o}}nte.

Das letzes Problem ist, dass die Heizung bei unsachgem{\"{a}}ssem Gebrauch -- also wenn sie sich zu sehr aufheizt --
besch{\"{a}}digt, da sich die Heizwiederst{\"{a}}nde selbst ausl{\"{o}}ten. Danach muss sie erst aufw{\"{a}}ndig
repariert werden und ist in der Zwischenzeit nicht benutzbar. Daher sollte die Alternativaufgabe keine besch{\"{a}}digbaren
Teile beeinhalten.

Auch w{\"{a}}re es sch{\"{o}}n wenn es noch subtilere M{\"{o}}glichkeiten der Fehlerinjektion g{\"{a}}be. Zum Beispiel ist
es nur m{\"{o}}glich die L{\"{u}}fter komplett abzuschalten, aber keine \textit{stuck-at} Fehler zu injezieren.
Gerade bei der Netzwerkkommunikation g{\"{a}}be es viele M{\"{o}}glichkeiten um Zeitfehler und Wertefehler zu injizieren.

Eine bereits existierende Alternative w{\"{a}}re die Wippe. Sie besteht aus einem Computergesteuerten Motor der eine
Wippe kippen kann auf der ein Ball liegt. Die Aufgabe ist es nun den Ball m{\"{o}}glichst in der Mitte zu balancieren.
Dieses System ist intuitiv verst{\"{a}}ndlich und reagiert --- im Gegensatz zur Heizung --- sofort. Allerdings ist
es ungeeignet um Konzepte der Ausfallsicherheit zu verdeutlichen: es gibt nur eine Komponente die ausfallen kann (den
Motor).

Momentan wird im Rahmen einer weiteren Bachelorarbeit ein {\"{a}}hnliches Prinzip im zweidimensionalen Raum entwickelt;
die Kugel soll nun auf einer Achse "Vorne-Hinten" und auf der Achse "Links-Rechts" m{\"{o}}glichst im Mittelpunkt liegen.
Auch die dadurch, wenigstens ansatzweise, vorhandene Redudandanz {\"{a}}ndert aber nichts am gr{\"{o}}{\ss}ten Kritikpunkt:
es gibt nur ein System wodurch nur eine Studentengruppe gleichzeitig arbeiten kann.

\clearpage
\section{Anforderungen}\label{anforderung}
Aus den Schwachstellen der vorhanden L{\"{o}}sung l{\"{a}}sst sich ableiten, was das neue System leisten soll:
\begin{enumerate}
	\item Die Alternativaufgabe soll sich stark von der ausfallsicheren Heizung unterscheiden, damit die Studierenden eine tats{\"{a}}chliche Wahl haben.
	\item Es muss m{\"{o}}glich sein mehrere Instanzen gleichzeitig laufen zu lassen. Damit werden die Koordinierungsprobleme vermieden.
	\item Es soll auch m{\"{o}}glich sein au{\ss}erhalb des MR Labores an der Problemstellung weiterzuarbeiten.
	\item In dem neuen System muss die Fehlerinjektion parametrisierbar sein. Damit ist es m{\"{o}}glich,
		die Aufgabe bei Bedarf zu vereinfachen oder zu verkomplizieren, zum Beispiel in dem bestimmte
		Arten der Fehlerinjektion ganz auschgeschaltet werden.
	\item Um die Aufgabe zu l{\"{o}}sen, muss eine Vielzahl von Konzepten der Ausfallsicherheit genutzt werden.
	\item Es soll visuell ansprechend sein.
	\item Es darf auch durch unsachgem{\"{a}}ssen Gebrauch nicht gesch{\"{a}}digt werden
\end{enumerate}

\clearpage
\section{Die balancierenden Roboter}
Viele dieser Anforderungen k{\"{o}}nnen am einfachsten mit einer Simulation abgedeckt werden. Diese kann gleichzeitig
von mehreren Gruppen genutzt werden und stellt keine Einschr{\"{a}}nkungen an die M{\"{o}}glichkeiten der Fehlerinjektion
oder der ben{\"{o}}tigten Konzepte.

An der Humboldt Universit{\"{a}}t Berlin (in Zusammenarbeit mit Daimler Benz) wurde eine solche
Simulation\cite{Werner00} entwickelt. In dieser soll eine simulierte Platte durch die Bewegung von 
simulierten Robotern ausbalanciert werden. Das Gewicht jedes Roboters wirkt auf die Platte, bringt sie also
aus dem Gleichgewicht.

Die Roboter m{\"{u}}ssen sich nun so bewegen, dass jede durch einen Roboter ausge{\"{u}}bte Kraft von einem
anderen Roboter eliminiert wird. Damit es nicht m{\"{o}}glich ist, einmal eine Stellung einzunehmen,
die zum Gleichgewicht f{\"{u}}hrt und dort zu verharren, haben die Roboter einen Energiespeicher, der
mit der Zeit leerer wird. Da die Roboter sich nur bewegen k{\"{o}}nnen solange sie noch Energiereserven haben, 
m{\"{u}}ssen sie hin und wieder diesen Speicher an einer Ladestation auff{\"{u}}llen.

Das Ziel dieser Simulation war zu demonstrieren, dass auch in Echtzeitsystem eine Konsensfindung m{\"{o}}glich
ist. Fall ein Ergebniss durch \textit{triple modular redudancy} und einen Voter bestimmt werden soll, 
verh{\"{a}}lt sich die naive Implementation im Falle eines \textit{timing faults}, so dass die
Einhaltung der Echtzeitanforderungen nicht mehr garantiert werden kann. 
\todo{raussuchen ob das nicht mit den relative mehrheit geloest wurde}

Die Simulation und die Controller wurden in Objective-C geschrieben und laufen auf dem NeXTStep Betriebssystem, 
w{\"{a}}hrend das Anzeigeprogramm Java basiert ist und z.B. auf
einem Windowsrechner laufen kann. Die Teilnehmern kommunizieren {\"{u}}ber CORBA 
miteinander\cite{predictablecorba}. CORBA ist ein Standard, {\"{u}}ber den Programme auf
mehreren Rechnern miteinander kommunizieren k{\"{o}}nnen, auch falls sie in verschiedenen Programmiersprachen 
geschrieben wurden. Zus{\"{a}}tzlich zur reinen RPC Funktionalit{\"{a}}t abstrahiert es, unter anderem, 
Transkationen und Zeitsynchronisation.

In das System k{\"{o}}nnen Fehler injiziert werden, zum Beispiel kann ein Roboter ferngesteuert bewegt werden. Auch
die Controller k{\"{o}}nnen entweder beendet werden oder ihnen kann die Netzwerkverbindung entzogen werden. Es ist
auch m{\"{o}}glich einen Roboter fernzusteuern und damit direkten Einfluss auf die Simulation zu nehmen.

Die balancieren Robotern w{\"{u}}rden den Anforderungen an vielen Stellen entsprechen, zum Beispiel
unterscheidet sie sich stark von der ausfallsicheren Heizung, es k{\"{o}}nnen mehrere Instanzen
gleichzeitig laufen und die Fehlerinjektion ist parametrisierbar. Gerade die dahinterliegende Idee ist
leicht verst{\"{a}}ndlich und gut geeignet; die Implementation weisst allerdings einige Schwachstellen auf.

Ein erster Kritikpunk ist das Anzeige nicht mehr zeitgem{\"{a}}ss ist, diese m{\"{u}}sste also neu entwickelt werden.

Auch ist das physikalische Modell der Simulation sehr rudiment{\"{a}}r: die Roboter k{\"{o}}nnen sich
holonomisch, also ohne Limitationen in alle Richtungen, bewegen. Dies ist aber bei den meisten Robotern
nicht der Fall, diese haben auf Grund ihres Aufbaus bestimmte Limitationen. Zum Beispiel ist es un{\"{u}}blich, 
dass sich Roboter vertikal frei bewegen k{\"{o}}nen. Des weiteren gibt es in der Simulation keine mechanischen 
Gleichgewichte -- auch dies eine unrealistische Vereinfachung gegen{\"{u}}ber der echten Welt. Die
physikalische Simulation m{\"{u}}sste also erweitert werden.

Das gr{\"{o}}{\ss}ere Problem ist allerdings das Alter der Simulation. Sie wurde in den neunziger Jahren auf 
NeXTStep Rechner entwickelt -- diese existieren an der Fachhochschule S{\"{u}}dwestfalen nicht, das Programm 
m{\"{u}}sste also erst portiert werden. Auch wird CORBA heutzutage nur noch wenig genutzt, also ist der Aufwand,
um sich in den Standard einzuarbeiten und sein Programm basierend auf diesem zu entwickeln, nicht vertretbar. 
Dies gilt gerade auch unter dem Gesichtspunkt, dass die Ausfallsicherheit im Vordergrund stehen sollte und
nicht die Einarbeitung in einen Standard.

Aus all diesen Gr{\"{u}}nden wurde entschieden, eine neue {\"{U}}bungsaufgabe zu entwickeln. Bei dieser wird
allerdings die Idee dieser Aufgabe beibehalten; die neue Aufgabe soll nur die identifizierten Schwachstellen
ausmerzen.

\clearpage
\section{Konkretisierung der Anforderungen}
Um die vorhandene Simulationsidee ohne die vorhanden Schwachstellen neu zu erstellen, so das die Anforderungen
(wie in \ref{anforderung} beschrieben erf{\"{u}}llt werden) ist es n{\"{o}}tig diese eher abstrakten Anforderungen in
technische Merkmale zu "{\"{u}}bersetzen".

Da es nicht m{\"{o}}glich sein soll die neue {\"{U}}bungsaufgabe zu besch{\"{a}}digen, muss es eine reine Softwareaufgabe
sein. Diese k{\"{o}}nnen im schlimmsten Fall einfach noch einmal neu gestartet werden um (tempor{\"{a}}re) Fehler zu
beheben.

Bei einer Softwarel{\"{o}}sung ist es auch m{\"{o}}glich die Ausf{\"{u}}hrung mehrerer Instanzen unabh{\"{a}}nig voneinander
zu erlauben, damit mehrere Studierendengruppen gleichzeitig ihre L{\"{o}}sung entwickeln k{\"{o}}nnen. Daher ist es notwendig
das es keinerlei Resourcen gibt die sich alle Instanzen teilen m{\"{u}}ssen --- das Programm sollte also selbstst{\"{a}}nig und
ohne weitere Komponenten laufen. Bei einem verteilten System das {\"{u}}ber ein IP-Netzwerk per Broadcast kommuniziert ist es
auch wichtig eine Trennung der verschiedenen Instanzen zu erm{\"{o}}glichen (dies kann z.B. durch die Verwendung verschiedener
Ports erreicht werden).

Desweiteren erlaubt der Einsatz einer Simulation ein eigenes Fehlermodell zu definieren. Wenn das Fehlermodell nicht fest
implementiert wird, sondern bei Bedarf ge{\"{a}}ndert werden kann soll es auch m{\"{o}}glich sein einzelne Fehlerquellen an/auszuschalten
oder die Wahrscheinlich mit der Fehler auftreten anzupassen. Damit w{\"{a}}re die Anforderung nach der Parametresierbarkeit
der Fehlerinjektion erf{\"{u}}llt.

Durch den Einsatz einer Simulation ist es auch m{\"{o}}glich die Visualisierung frei zu w{\"{a}}hlen; zum Beispiel kann die 2D
Vogelperspektive wie in der Orginalimplementation der balancierenden Roboter durch eine 3D Ansicht abgel{\"{o}}st werden.

Durch die Simulationsidee, den Ablauf der Steuerung der balancierenden Roboter, ist der Einsatz verschiedener Techniken um
fehlertolerante Systeme --- wie zum Beispiel die Konsensbildung mit einem Voter oder verschiedene Arten der Vorw{\"{a}}rtsfehlerkorrektur ---
n{\"{o}}tig. Dies ist gerade im Lehrkontext wichtig, damit m{\"{o}}glichst viele Konzepte sinnvoll angewandt werden
k{\"{o}}nnen und es im besten Fall sogar n{\"{o}}tig ist das die Studenten zwischen verschiedenen Alternativen w{\"{a}}hlen
m{\"{u}}ssen.

\clearpage
\section{Konzeption}
\subsection{Simulationsidee}
Es wurde sich entschieden die Grundidee der Simulation beizubehalten, diese allerdings neu zu implementieren um die Kritikpunkte am
bestehenden System auszumerzen. Im folgenden wird die Grundidee noch einmal konkretisiert:

Die simulierte Welt besteht aus einer kreisf{\"{o}}rmigen Platte. Auf dieser k{\"{o}}nnen bis zu \gls{N}
Roboter und $1$ F{\"{u}}llstation (\gls{F}) platziert werden. Die Summe alle Gewichte kippt die Platte;
sind die Gewichte zu ungleichm{\"{a}}{\ss}ig verteilt, kippt die Platte um und die Simulation endet.

Die Roboter k{\"{o}}nnen sich frei auf der Platte bewegen, verbrauchen dabei aber Energie und m{\"{u}}ssen diese dann irgendwann
an der F{\"{u}}llstation auff{\"{u}}llen. Auch wenn die Roboter sich nicht bewegen, verbrauchen sie Energie (allerdings weniger
schnell).

Gesteuert werden die Roboter von bis zu \gls{M} $(M \geq N)$ Controllern. Einer oder mehr Controller stimmen sich ab,
so dass:
\begin{itemize}
\item die Roboter ihre Energie immer rechtzeitig auff{\"{u}}llen
\item die Roboter nicht kollidieren
\item die Platte nicht kippt
\end{itemize}

Dieser Abstimmungsvorgang sollte fehlertolerant implementiert werden, so dass auch beim Ausfall eines (oder mehrerer) Controller die Roboter sich immer noch koordiniert bewegen.
(Abh{\"{a}}ngig vom Verh{\"{a}}ltnis der Anzahl der Controller zur Anzahl der Roboter k{\"{o}}nnen verschiedene Stufen der Fehlertoleranz erreicht werden.\cite[s.149]{Werner00})
Daraus folgt das die Studierenden in ihrer L{\"{o}}sung eine Konsensbildung implementieren m{\"{u}}ssen.

Die Voter und Controller laufen auf Virtuellen Maschinen, jeweils eine VM pro Voter- oder Controllerinstanz.
Diese VMs befinden sich in einem Netzwerk, das durch eine Fehlerinjektion UDP Pakete verf{\"{a}}lscht --
dies simuliert ein fehlertr{\"{a}}chtiges Netzwerk, wie es zum Beispiel bei Funknetzwerken der Fall ist.
Es wird vorgegeben, dass die gesamte Kommunikation der Studentenprogramme {\"{u}}ber UDP stattfinden muss.
Dies f{\"{u}}hrt dazu das die Studierenden Gegenmassnahmen gegen die Verf{\"{a}}lschung ergreifen m{\"{u}}ssen, denkbar
w{\"{a}}hre hier zum Beispiel eine Kanalkodierung zur Vorw{\"{a}}rtsfehlerkorrektur.
Die Kommunikation von Simulation zu den Votern ist nicht betroffen, sie soll nicht verf{\"{a}}lscht werden. (Statdessen
kann die Schnittstelle gezieltere Verf{\"{a}}lschungen vornehmen.)

\begin{figure}
	\centering
	\includevisio[width=\textwidth]{Netzwerk}
	\caption{Aufteilung der Netzwerkteilnehmer}
	\label{fig:network}
\end{figure}

Zusammenfassend besteht das ganze System aus diesen Teilen:
\begin{itemize}
	\item Die Simulation berechnet die Bewegungen und implementiert das physikalische Modell. Sie {\"{u}}bernimmt auch die Visualisierung. Per Definition ist sie ausfallsicher.
	\item Der Voter sammelt die Steuerkommandos von den Controllern, bildet daraus das Steuerergebniss und sendet dies an die Simulation. Er ist per Definition ausfallsicher gegen \textit{crash failures}.
	\item Die Controller generieren Steuerkommandos. Sie k{\"{o}}nnen jederzeit ausfallen.
\end{itemize}

\paragraph{Nutzung durch die Studenten} Von den Studierenden muss nicht die gesamte Simulation erstellt werden;
die {\"{U}}bungsaufgabe bezieht sich nur auf die Abstimmung zwischen den Controllern und die Ansteuerung der Roboter.
Daher ist es notwendig, ein Interface ins "Innere" der Simulation bereitzustellen, das dann von den Studenten genutzt wird.

\subsection{Architekturkonzept}
Nach dem ausarbeiten der Anforderungen an das Simulationswerkzeug und die Entscheidung {\"{u}}ber den Simulationsablauf (inklusive
der Trennung zwischen f{\"{u}}r die Studierenden vorgefertigten Teil und den von diesen selbst zu implementierenden) ist es n{\"{o}}tig
die Systembestandteile aufzulisten. Dabei werden auch die Beziehungen zwischen ihnen aufgef{\"{u}}hrt, da diese Einfluss auf die
Architektur haben.

\begin{figure}
	\centering
	\includevisio[width=\textwidth]{Komponenten1}
	\caption{Ben{\"{o}}tigte Systembestandteile und ihre Beziehungen}
	\label{fig:arch_pre}
\end{figure}

Der Hauptbestandteil der Simulation ist die Physiksimulation. Sie ist daf{\"{u}}r zust{\"{a}}ndig
das sich die Roboter bewegen, betankt werden k{\"{o}}nnen, muss Informationen {\"{u}}ber den
Status der Simulation (z.B. Roboterpositionen) bereitstellen und auch die Roboter basierend
auf den Steuerbefehlen der Voter bewegen (unter Beachtung aller physikalischen Eigenschaften
des Roboters und der Fehlerinjektion).

Um die Roboter zu steuern muss a) der Status der Roboter bekannt sein b) es f{\"{u}}r den
Voter m{\"{o}}glich sein die Steuerbefehle an die Simulation weiter zu reichen. Beides
erm{\"{o}}glicht das Interface.

F{\"{u}}r die Fehlerinjektion ist der Fehlerinjektionssmanager zus{\"{a}}ndig. Die Physiksimulation
benutzt diesen um Roboterspezifische Fehler\ref{fm-robot} zu injezieren, w{\"{a}}hrend das
Interface basierend auf dem Fehlerinjektionsmanager die Informationen {\"{u}}ber den
Status der Welt verf{\"{a}}lscht.

Um den Simulationsstatus verfolgen zu k{\"{o}}nnen ist eine visuelle Anzeige hilfreich. Daher
ist ein Bestandteil der Simulation ein Anzeigeprogramm.

Jede Voterinstanz ist daf{\"{u}}r zust{\"{a}}ndig ihren Roboter in der Simulation zu steuern.
Daf{\"{u}}r m{\"{u}}ssen die Steuerkommandos an die Physiksimulation weitergeleitet werden,
dies {\"{u}}bernimmt das Interface. Der Controller ist komplett den Studenten {\"{u}}berlassen-
Es gibt nur die Einschr{\"{a}}nkung das alle Kommunikation zur Simulation hin, {\"{u}}ber den Voter erfolgen muss.

\subsection{Kommunikation zwischen den Systemteilen}
Bei verteilten Systemen (wie diesem) ist einer der wichtigsten Punkte wie die Kommunikation zwischen den Systemteilen abl{\"{a}}uft.
Hierbei kann zwischen zwei Gruppierungen unterschieden werden: einmal die Kommunikation zwischen Simulation und Voter und andererseits
die Kommunikationen zwischen den Controllern und zwischen Controller und Voter. Da die letztere von den Studierenden geplant werden soll,
wird sie hier nicht weiter untersucht.

Da alle Voter in der gleichen Welt miteinander interagieren sollen, ist es am einfachsten wenn die Simulation ein Server ist, zu dem sich alle
verbinden. Dieser Server kann dann intern die Simulation vorantreiben und nur die Ergebnisse dieser weiterversenden. Die Alternative
w{\"{a}}re ein System ohne zentrale Instanz in dem die Simulation auf jedem Robter ausgef{\"{u}}hrt wird. In diesem Fall gibt es
allerdings das Problem das sich der Status der Simulationen voneinander desychnorisieren kann, zum Beispiel wenn ein Voter
eine schw{\"{a}}cheren CPU hat, die l{\"{a}}nger zur Berechnung eines Simulationstaktes braucht als die anderen Voter. Daher ist
das Modell mit zentrale Instanz vorzuziehen; es stellt automatisch sicher das alle Voter (im Normalfall, also ohne Fehler)
die gleichen Informationen kriegen und anhand dieser dann reagieren.

Durch die Verwendung einer zentralen Instanz ist die eine H{\"{a}}lfte der Isolation zwischen verschiedenen Instanzen realisiert:
Die Voter jeder Instanz verbinden sich mit ihrer Instanz, diese sendet ihre Informationen nur an die verbundenen Voter.
\footnote{Der andere Teil --- die Isolation zwischen verschiedenen Instanzen in Bezug auf Controller und Voter --- kann entweder
durch die Benutzung verschiedener Ports oder den Gebrauch mehrere \textit{subnets} erreicht werden.}

Ein Nachteil dieser L{\"{o}}sung ist das sie einen \textit{single point of failure} erschafft. Fehler in dem Simulationsprogramm
wirken sich direkt auf das ganze System aus; daher wird definiert das dieses keine Fehler enth{\"{a}}hlt.

F{\"{u}}r den zeitlichen Ablauf in der Simulation sind zwei M{\"{o}}glichkeiten denkbar: eine rundenbasierte Abfolge oder eine
Abfolge in Echtzeit. Bei der rundenbasieren Simulationstrategie wird der Status der Simulation immer nach festgelegten Intervallen
ver{\"{a}}ndert. In diesem Fall w{\"{a}}re es denkbar das die Controller und Voter 250ms Zeit haben ihre Bewegungsvorschl{\"{a}}ge
zu berechnen und diese an die Simulation schicken. Diese sammelt sie, wendet sie alle auf einmal an und versendet den neuen Status der
Welt. Damit beginnt die n{\"{a}}chste Runde. Die Alternative ist es das Bewegungsvorschl{\"{a}}ge direkt angewendet werden, falls
der Abstimmungsvorgang zwischen den Controllern also schneller vonstatten geht bewegen sich die Roboter auch {\"{o}}fter.

Beide M{\"{o}}glichkeiten w{\"{a}}hren realisierbar, allerdings wird die Echtzeitmethode vorgezogen. Einerseits da, gerade bei einer
3D-Ansicht, es unangehnem auff{\"{a}}llt wenn auch nur wenige Millisekunden nichts passiert --- es wirkt als w{\"{u}}rde die
Simulation stocken. Desweiteren ist es auch eine unrealistische Vereinfachung gegen{\"{u}}ber der realen Welt w{\"{a}}hre,
die sich nun einmal konstant ver{\"{a}}ndert.

Dies hei{\ss} zwangsl{\"{a}}ufig das eine Event-gesteuerten Kommunikation eingesetzt werden muss. Sender und Empf{\"{a}}nger
sollen zeitlich entkoppelt sein, haupts{\"{a}}chlich ihre eigenen Aufgaben durchf{\"{u}}hren und erst zu "passenden" Zeitpunkten
mit den jeweils anderen Kommunikationspartnern interagieren. 

Damit die Studenten sich nicht um die Kommunikation zur Simulation k{\"{u}}mmern m{\"{u}}ssen brauchen sie eine Bibliothek welche
diese Funktionalit{\"{a}}t bereitstellt. Sie kann benutzt werden um einen neuen Roboter zu erstellen und diesen zu steuern.
Im Fehlermodell gibt es auch eine Anforderung das einzelene Voter andere Informationen {\"{u}}ber den Status der Welt
bekommen sollen als andere. Daher ist die Bibliothek nicht nur f{\"{u}}r die reine Kommunikation zust{\"{a}}ndig, sondern wird auch
benutzt um diese Art von Fehler zu injizieren.


