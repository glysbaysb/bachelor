\clearpage
\section{Einf{\"{u}}hrung}
\begin{figure}
	\centering
	\includevisio[width=\textwidth]{simulation}
	\caption{Screenshot der Simulation}
	\label{fig:simulation}
\end{figure}

\subsection{Motivation} Seit der Einf{\"{u}}hrung der Computer und vor allem seit dem rasanten Wachstums des
Internets, werden Computer in immer mehr Bereichen eingesetzt. Es gibt nur noch wenige Berufe oder 
Freizeitaktivit{\"{a}}ten die komplett ohne auskommen; Die Buchhaltung geschieht komplett elektronisch und
das Geld wird elektronisch {\"{u}}berwiesen, anstatt in einer Lohnt{\"{u}}te ausgeh{\"{a}}ndigt zu werden.
Und um herauszufinden ob der Lohn angekommen ist benutzt man Onlinebanking, wobei eine
unm{\"{o}}glich absch{\"{a}}tzbare Anzahl an vernetzten Computern beteiligt ist. Auch komplett ohne Technik
durchf{\"{u}}hrbare Freizeitaktivit{\"{a}}ten wie das Kegeln sind heute ohne Computerunterst{\"{u}}tzung
kaum noch vorstellbar -- in den Kegelbahnen z{\"{a}}hlt ein Computer f{\"{u}}r jeden Spieler mit wie viele
Punkte erreicht wurden und stellt die umgeworfenen Kegel automatisch wieder auf.

Dies bietet enorme, jeden Tag ersichtlich werdene Vorteile, birgt jedoch auch Risiken. Die Komplexit{\"{a}}t,
oder den Aufwand, die der "Nutzer" bew{\"{a}}ltigen muss, sinkt zwar (meistens), allerdings wird das
System fehleranf{\"{a}}lliger. Es gibt mehr Komponenten, also kann mehr kaputt gehen.

Zu einem Problem wird dies falls es um lebenswichtige Bereiche wie die
Strom- und Wasserversorgung, Fahrassistenz und {\"{a}}hnliches geht. Auch kleine Fehler dort k{\"{o}}nnen
enorme Konsequen haben. 

Trotzdem wird dieser Aspekt oft vernachl{\"{a}}ssigt. Ein tragisches Beispiel ist der Therac-25, eine
Maschine zur Strahlentherapie. Durch verschiedene Softwarefehler kam es, unter bestimmten Umst{\"{a}}nden, zu
{\"{u}}berh{\"{o}}hten Strahlendosen die teilweise t{\"{o}}dlich endeten.

Eine offensichtliche Gegenma{\ss}nahme ist es die Software gr{\"{u}}ndlich zu testen. Es gibt verschiedene
Arten von Tests und Teststrategien, die das System aus unterschiedlichen Blickwinkeln betrachten. Hierbei kann zwischen
\textit{static} und \textit{dynamic testing} unterschieden werden. Bei statischem Testen wird der Quellcode untersucht,
das Programm oder Programmbestandteile aber nicht ausgef{\"{u}}hrt. Ein Beispiel daf{\"{u}}r ist \textit{static analysis},
bei der der Programmcode auf auf{\"{a}}llige Codekonstrukte untersucht wird, die ha{\"{u}}fig zu Fehlern f{\"{u}}hren -- wie zum
Beispiel die Benutzung nicht initalsierter Variablen. Ein anderer Ansatz sind die \textit{code reviews} bei
denen der programmierte Code mit weiteren Programmieren besprochen wird um nach dem Vier Augen Prinzip weitere Probleme zu
identifizieren. \todo{jpl erwaehnen?}

Ein Beispiel f{\"{u}}r das dynamische Testen sind Unit Tests, bei denen eine logische Einheit des Systems isoliert getestet wird
in dem sie mit vorher festgelegten Parametern ausgef{\"{u}}hrt wird und das Ergebniss mit einem erwarteten Ergebniss verglichen
wird. Zum Beispiel k{\"{o}}nnen bei einem Navigationsger{\"{a}}t die Wegfindung, die Anzeige und das interpretieren der Kartendaten
als eigene Module programmiert und getestet werden. Um die Wegfindung zu testen w{\"{u}}rde dann eine k{\"{u}}nstliche Karte genutzt
und getestet ob der Wegfindungsalgorithmus f{\"{u}}r vorher definierte Strecken auf dieser Karte die k{\"{u}}rzesten Wege
findet.

Es gibt allerdings auch F{\"{a}}lle in denen es nicht machbar ist das System komplett durchzutesten. Beispielweise ist es
mit spezieller Hardware m{\"{o}}glich den Befehlssatz einer CPU zu emulieren und zu {\"{u}}berpr{\"{u}}fen ob bestimmte Befehlskombinationen
zu Problemen f{\"{u}}hren. Allerdings ist die Geschwindigkeit der Tests um mehrere Gr{\"{o}}ssenordnungen kleiner als die der tats{\"{a}}chlichen
CPU, so das eine eine x86 CPU in der ersten Sekunde mehr Instruktionen ausf{\"{u}}hrt als w{\"{a}}hrend des gesamten Testzyklus\cite{kaplan}.
Es ist also unm{\"{o}}glich die CPU komplett durchzutesten, was dazu f{\"{u}}hrt das CPUs trotzdem noch Fehler enthalten, ein ber{\"{u}}hmtes
Beispiel ist der Pentium F00F Bug.

Da also Testen alleine nicht ausreicht ist es besonders wichtig bei der Designphase angefangen die Ausfallsicherheit immer einzuplanen. Daf{\"{u}}r
muss ein Problembewusstsein geschaffen werden. Um dann wirklich ausfallsichere System zu entwickeln braucht man nat{\"{u}}rlich auch bestimmte Kentnisse 
{\"{u}}ber das Design und die Entwicklung solcher.

\subsection{Aufgabenstellung} Dies ist die Aufgabe des Moduls "Ausfallsichere Systeme". Daf{\"{u}}r gibt es einen theoretischen (die Vorlesung) und
einen praktischen Teil (eine {\"{U}}bungsaufgabe). Die {\"{U}}bungsaufgabe soll eine M{\"{o}}glichkeit geben das theoretische Wissen anzuwenden.
Dabei werden die Studenten aus den gelernten Techniken die richtigen f{\"{u}}r die Aufgabe heraussuchen m{\"{u}}ssen, diese gegen Alternativen
abw{\"{a}}gen und sie dann zu implementieren. Durch die praktische Anwendung wird das gelernte wiederholt und vertieft, was zu einem besseren
Verst{\"{a}}ndnis f{\"{u}}hrt.

Die Aufgabe dieser Bachelorarbeit ist die Konzeption der selbigen. Zus{\"{a}}tzlich soll das fertige Produkt auch im Rahmen von Informationsveranstaltungen als Demonstrationsprojekt
nutzbar sein und gerade auch Menschen ohne Fachkentnisse einen Einblick in die Komplexit{\"{a}}t ausfallsicherer Systeme geben, dabei aber trotzdem interessant
sein.

\subsection{Gliederung} Diese Bachelorarbeit besteht aus zwei Teilen. Im ersten wird die Aufgabenstellung entwickelt, im zweiten der L{\"{o}}sungsweg skizziert.

Der erste Teil besteht aus einer Einf{\"{u}}hrung, um den Sinn und Zweck dieser Arbeit zu verdeutlichen. Danach wird erkl{\"{a}}rt, warum die
\hyperref[heizung]{existierende {\"{U}}bungsaufgabe} nicht ausreicht; basierend darauf werden die Anforderungen an die neue Aufgabe entwickelt.

Im zweiten Teil werden als erstes die ben{\"{o}}tigten Grundlagen zur Umsetzung erkl{\"{a}}rt. Dabei geht es einerseits um mechanische und physische Konzepte wie das
\hyperref[diffs]{\textit{differential steering}} und die mathematische Grundlagen der Vektorrechnung, aber auch um Informationstechnologische Aspekte wie die Serialisierung von Daten oder
verschiedene Netzwerkkommunikationsarten. Darauf aufbauend wird dann die Implementierung beschrieben, mit besonderem Fokus auf dem Fehlermodell und der
Fehlerinjektion.

Zum Schluss wird die Simulation anhand der Kriterien evaluiert und ein Fazit gezogen.

\clearpage
\section{Die ausfallsichere Heizung}\label{heizung}
Eine {\"{U}}bungsaufgabe im Module Ausfallsichere System wurde im Sommersemester 2016 an der FH S{\"{u}}dwestfalen entwickelt. Das Ziel war es, mithilfe zwei von Heizk{\"{o}}rpern, zweier
L{\"{u}}fter, einer Klappe und mehrer Temperatursensoren eine Temperatur zu regeln. F{\"{u}}r die Regelung m{\"{u}}ssen sich drei Rechner abstimmen, denn einer kontrolliert
beide Heizungen, einer beide L{\"{u}}fter und der dritte die Klappe. Um sich abzustimmen k{\"{o}}nnen die Rechner {\"{u}}ber UDP und I\textsuperscript{2}C miteinander kommunizieren.

Das Gesamtsystem ist Y-f{\"{o}}rmig aufgebaut; an den Armen des Ypsilon befindet sich jeweils ein Heizk{\"{o}}rper und ein L{\"{u}}fter; an dem Punkt, an dem sich
die Arme treffen, ist die Klappe, die den Luftstrom eines Arms ganz oder teilweise blockieren kann (diese Luft wird dann nach oben abgeleitet).

Um die Temperaturen in den Armen und die Temperatur des Luftstromes zu messen gibt es Temperatursensoren. Jeweils ein Temperatursensor im Luftausgangsstrom ist einem
der Rechner zugeordnet. Zus{\"{a}}tzlich hat der L{\"{u}}ftungsrechner einen Temperatursensor pro Arm zwischen L{\"{u}}fter und Heizung, und der Heizungsrechner jeweils
einen Temperatursensor vor der Heizung.

\begin{figure}
	\centering
	\includevisio[width=\textwidth]{HeizungHW}
	\caption{Aktoren und Sensoren der Heizung}
	\label{fig:heizunghw}
\end{figure}

All diese Bestandteile k{\"{o}}nnen auf verschiedene Arten fehlerhaft sein. Die Aufgabe der Studierenden
ist es, sich f{\"{u}}r die verschiedenen Fehlerkombinationen
geeignete Strategien auszudenken, um die Auswirkungen zu minimieren.

Beispielsweise kann es vorkommen das ein Heizk{\"{o}}rper ausf{\"{a}}llt, beziehungsweise dass dem
Heizk{\"{o}}rper ein Fehler injiziert wird\footnote{In diesem Fall wird die Stromversorgung gekappt},
also sich nicht weiter aufheizen kann. Dies muss erst einmal erkannt werden, zum Beispiel
durch den Vergleich des Sollwertes der Heizungsansteuerung und den Lufttemperaturen vor und hinter der Heizk{\"{o}}rper. Falls diese Temperaturen gleich sind,
wurde die Luft die vom L{\"{u}}fter Richtung Ausgang bewegt wurde, nicht aufgew{\"{a}}rmt, ergo heizt dieser Heizk{\"{o}}rper nicht. Dann k{\"{o}}nnen sich die
Rechner abstimmen, wie sie die Temperatur trotzdem ansteigen lassen k{\"{o}}nnen, zum Beispiel ob der {\"{u}}brig gebliene Heizk{\"{o}}rper st{\"{a}}rker heizen
soll, oder ob dieser weniger gek{\"{u}}hlt werden soll.

{\"{A}}hnlich ist es bei einem Ausfall der L{\"{u}}fter. 

Um die Kommunikation zu testen, k{\"{o}}nnen auch die Kommunikationswege ausfallen\footnote{Hierbei
wird das LAN-Kabel aus dem Switch gezogen, wodurch dieser Rechner keine Verbindung mehr zu den anderen hat.
Das gleiche gilt f{\"{u}}r die I\textsuperscript{2}C Leitungen}.
Was passiert, wenn der Heizungsrechner nicht mehr erreichbar ist, aber eine Heizung weniger stark heizen soll?
Da es zwei Kommunikationswege gibt, kann normalerweise UDP/IP f{\"{u}}r die Kommunikation verwendt werden
und I\textsuperscript{2}C nur als \textit{hot standby}. Alternativ wird ein {\"{U}}bertragungsweg nur
f{\"{u}}r Daten genutzt und der andere um zu signalisieren, dass dieser Rechner noch das
Steuerprogramm ausf{\"{u}}hrt. Der Ausfall einer der beiden Leitung kann anhand der Aktivit{\"{a}}t auf der
anderen erkannt werden.

Als letztes k{\"{o}}nnen auch die Temperatursensoren ausfallen. Im Luftausgangsstrom, wo drei Sensoren 
nebeneinander angeordnet sind, ist es m{\"{o}}glich den
Ausfall eines Sensors anhand der Diskrepanz der Messergebnisse aller Sensoren zu erkennen. Eine m{\"{o}}gliche 
Strategie, um die Ausgangstemperatur zu
bestimmen, w{\"{a}}re also, die \textit{triple modular redudancy} auszunutzen und den Mittelwert aller nicht klar als 
fehlerhaft erkennbaren Sensoren zu bilden.
Es ist auch denkbar, die vorherigen Messwerte zu benutzen um anhand unrealistischer Spr{\"{u}}nge der Messwerte zu 
erkennen, dass ein Sensor einen fehlerhaften Messwert geliefert hat.

Nat{\"{u}}rlich ist es auch denkbar, dass mehrere dieser Fehler auftreten, also beispielsweise f{\"{a}}llt
erst ein Sensor, dann das Netzwerk aus und danach steckt die Klappe fest.
Gerade bei Doppelfehlern, in denen eine L{\"{u}}ftung und ein Heizk{\"{o}}rper in unterschiedlichen {\"{A}}rmen 
ausfallen, gibt es die Gefahr, dass sich ein Arm {\"{u}}berhitzt und besch{\"{a}}digt wird.

Weil die Heizungen eine beschr{\"{a}}nkte Leistung haben und eine gro{\ss}e Menge Luft 
($ \approx (13*13*55)cm^3$) aufheizen m{\"{u}}ssen, ist die Regelung sehr tr{\"{a}}ge. Damit ist es als
Vorf{\"{u}}hrobjekt zum Beispiel f{\"{u}}r Schulklassen ungeeignet, diese k{\"{o}}nnen nicht 10 Minuten warten
bis die Temperatur eingeregelt wurde, dann ein Fehler injiziert wurde (zum Beispiel eine Heizung
ausf{\"{a}}llt), dieser Ausfall erkannt wird und dann gegengesteuert wurde.

Desweiteren gibt es dieses System nur einmal. Das bedeutet einerseits, dass es bei gro{\ss}en Gruppen
an Sch{\"{u}}lern unm{\"{o}}glich wird, dass alle etwas f{\"{u}}hlen k{\"{o}}nnen und andererseits, es durch
die lange Regelzeit zu Koordinationsproblemen kommt. W{\"{a}}hrend eine Gruppe ihr Programm testet, m{\"{u}}ssen
alle anderen Gruppen warten. Da fast jeder Test mehrere Minuten dauert, verbringen die Gruppen die
allermeiste Zeit mit warten und nur wenig Zeit mit produktiver Arbeit.

Das letzes Problem ist, dass die Heizung bei unsachgem{\"{a}}ssem Gebrauch -- also wenn sie sich zu sehr aufheizt --
besch{\"{a}}digt, da sich die Heizwiederst{\"{a}}nde selbst ausl{\"{o}}ten. Danach muss sie erst aufw{\"{a}}ndig
repariert werden und ist in der Zwischenzeit nicht benutzbar.

\clearpage
\section{Anforderungen}\label{anforderung}
Aus den Schwachstellen der vorhanden L{\"{o}}sung l{\"{a}}sst sich ableiten, was das neue System leisten soll:
\begin{enumerate}
	\item Die Alternativaufgabe soll sich stark von der ausfallsicheren Heizung unterscheiden, damit die Studierenden eine tats{\"{a}}chliche Wahl haben.
	\item Es muss m{\"{o}}glich sein mehrere Instanzen gleichzeitig laufen zu lassen. Damit werden die Koordinierungsprobleme vermieden.
	\item In dem neuen System muss die Fehlerinjektion parametrisierbar sein. Damit ist es m{\"{o}}glich,
		die Aufgabe bei Bedarf zu vereinfachen oder zu verkomplizieren, zum Beispiel in dem bestimmte
		Arten der Fehlerinjektion ganz auschgeschaltet werden.
	\item Um die Aufgabe zu l{\"{o}}sen, muss eine Vielzahl von Konzepten der Ausfallsicherheit genutzt werden.
	\item Es soll visuell ansprechend sein.
	\item Es darf auch durch unsachgem{\"{a}}{\ss}en Gebrauch nicht gesch{\"{a}}digt werden
\end{enumerate}

\clearpage
\section{Die balancierenden Roboter}
An der Humboldt Universit{\"{a}}t Berlin (in Zusammenarbeit mit Daimler Benz) wurde eine
Simulation\cite{Werner00} entwickelt. In der Simulation soll eine simulierte Platte durch die Bewegung von 
simulierten Robotern ausbalanciert werden. Das Gewicht jedes Roboters wirkt auf die Platte, bringt sie also
aus dem Gleichgewicht.

Die Roboter m{\"{u}}ssen sich nun so bewegen, dass jede durch einen Roboter ausge{\"{u}}bte Kraft von einem
anderen Roboter eliminiert wird. Damit es nicht m{\"{o}}glich ist, einmal eine Stellung einzunehmen,
die zum Gleichgewicht f{\"{u}}hrt und dort zu verharren, haben die Roboter einen Energiespeicher, der
mit der Zeit leerer wird. Da die Roboter sich nur bewegen k{\"{o}}nnen solange sie noch Energiereserven haben, 
m{\"{u}}ssen sie hin und wieder diesen Speicher an einer Ladestation auff{\"{u}}llen.

Das Ziel dieser Simulation war zu demonstrieren, dass auch in Echtzeitsystem eine Konsensfindung m{\"{o}}glich
ist. Fall ein Ergebniss durch \textit{triple modular redudancy} und einen Voter bestimmt werden soll, 
verh{\"{a}}lt sich die naive Implementation im Falle eines \textit{timing faults}, so dass die
Einhaltung der Echtzeitanforderungen nicht mehr garantiert werden kann. 
\todo{raussuchen ob das nicht mit den relative mehrheit geloest wurde}

Die Simulation und die Controller wurden in Objective-C geschrieben und laufen auf dem NeXTStep Betriebssystem, 
w{\"{a}}hrend das Anzeigeprogramm Java basiert ist und z.B. auf
einem Windowsrechner laufen kann. Die Teilnehmern kommunizieren {\"{u}}ber CORBA 
miteinander\cite{predictablecorba}. CORBA ist ein Standard, {\"{u}}ber den Programme auf
mehreren Rechnern miteinander kommunizieren k{\"{o}}nnen, auch falls sie in verschiedenen Programmiersprachen 
geschrieben wurden. Zus{\"{a}}tzlich zur reinen RPC Funktionalit{\"{a}}t abstrahiert es, unter anderem, 
Transkationen und Zeitsynchronisation.

In das System k{\"{o}}nnen Fehler injiziert werden, zum Beispiel kann ein Roboter ferngesteuert bewegt werden oder die Controller k{\"{o}}nnen. \todo{}

Die balancieren Robotern w{\"{u}}rden den Anforderungen an vielen Stellen entsprechen, zum Beispiel
unterscheidet sie sich stark von der ausfallsicheren Heizung, es k{\"{o}}nnen mehrere Instanzen
gleichzeitig laufen und die Fehlerinjektion ist parametrisierbar. Ein erster Kritikpunk ist das Anzeige
nicht mehr zeitgem{\"{a}}ss ist, diese m{\"{u}}sste also neu entwickelt werden.

Auch ist das physikalische Modell der Simulation sehr rudiment{\"{a}}r: die Roboter k{\"{o}}nnen sich
holonomisch, also ohne Limitationen in alle Richtungen, bewegen. Dies ist aber bei den meisten Robotern
nicht der Fall, diese haben auf Grund ihres Aufbaus bestimmte Limitationen. Zum Beispiel ist es un{\"{u}}blich, 
dass sich Roboter vertikal frei bewegen k{\"{o}}nen. Des weiteren gibt es in der Simulation keine mechanischen 
Gleichgewichte -- auch dies eine unrealistische Vereinfachung gegen{\"{u}}ber der echten Welt. Die
physikalische Simulation m{\"{u}}sste also erweitert werden.

Das gr{\"{o}}{\ss}ere Problem ist allerdings das Alter der Simulation. Sie wurde in den neunziger Jahren auf 
NeXTStep Rechner entwickelt -- diese existieren an der Fachhochschule S{\"{u}}dwestfalen nicht, das Programm 
m{\"{u}}sste also erst portiert werden. Auch wird CORBA heutzutage nur noch wenig genutzt, also ist der Aufwand,
um sich in den Standard einzuarbeiten und sein Programm basierend auf diesem zu entwickeln, nicht vertretbar. 
Dies gilt gerade auch unter dem Gesichtspunkt, dass die Ausfallsicherheit im Vordergrund stehen sollte und
nicht die Einarbeitung in einen Standard.

Aus all diesen Gr{\"{u}}nden wurde entschieden, eine neue {\"{U}}bungsaufgabe zu entwickeln.

\clearpage
\section{Simulationsidee}
Die simulierte Welt besteht aus einer kreisf{\"{o}}rmigen Platte. Auf dieser k{\"{o}}nnen bis zu \gls{N}
Roboter und $1$ F{\"{u}}llstation (\gls{F}) platziert werden. Die Summe alle Gewichte kippt die Platte;
sind die Gewichte zu ungleichm{\"{a}}{\ss}ig verteilt, kippt die Platte um und die Simulation endet.

Die Roboter k{\"{o}}nnen sich frei auf der Platte bewegen, verbrauchen dabei aber Energie und m{\"{u}}ssen diese dann irgendwann
an der F{\"{u}}llstation auff{\"{u}}llen. Auch wenn die Roboter sich nicht bewegen, verbrauchen sie Energie (allerdings weniger
schnell).

Gesteuert werden die Roboter von bis zu \gls{M} $(M \geq N)$ Controllern. Einer oder mehr Controller stimmen sich ab,
so dass:
\begin{itemize}
\item die Roboter ihre Energie immer rechtzeitig auff{\"{u}}llen
\item die Roboter nicht kollidieren
\item die Platte nicht kippt
\end{itemize}

Dieser Abstimmungsvorgang sollte fehlertolerant implementiert werden, so dass auch beim Ausfall eines (oder mehrerer) Controller die Roboter sich immer noch koordiniert bewegen.
(Abh{\"{a}}ngig vom Verh{\"{a}}ltnis der Anzahl der Controller zur Anzahl der Roboter k{\"{o}}nnen verschiedene Stufen der Fehlertoleranz erreicht werden.\cite[s.149]{Werner00})

Die Voter und Controller laufen auf Virtuellen Maschinen, jeweils eine VM pro Voter- oder Controllerinstanz.
Diese VMs befinden sich in einem Netzwerk, das durch eine Fehlerinjektion UDP Pakete verf{\"{a}}lscht --
dies simuliert ein fehlertr{\"{a}}chtiges Netzwerk, wie es zum Beispiel bei Funknetzwerken der Fall ist.
Es wird vorgegeben, dass die gesamte Kommunikation {\"{u}}ber UDP stattfinden muss. Die Kommunikation von Simulation zu den Votern ist davon nicht betroffen, sie soll nicht verf{\"{a}}lscht werden.

\begin{figure}
	\centering
	\includevisio[width=\textwidth]{Netzwerk}
	\caption{Aufteilung der Netzwerkteilnehmer}
	\label{fig:network}
\end{figure}

Zusammenfassend besteht das ganze System aus diesen Teilen:
\begin{itemize}
	\item Die Simulation berechnet die Bewegungen und implementiert das physikalische Modell. Sie {\"{u}}bernimmt auch die Visualisierung. Per Definition ist sie ausfallsicher.
	\item Der Voter sammelt die Steuerkommandos von den Controllern, bildet daraus das Steuerergebniss und sendet dies an die Simulation. Er ist per Definition ausfallsicher gegen \textit{crash failures}.
	\item Die Controller generieren Steuerkommandos. Sie k{\"{o}}nnen jederzeit ausfallen.
\end{itemize}

\paragraph{Nutzung durch die Studenten} Von den Studierenden muss nicht die gesamte Simulation erstellt werden; die {\"{U}}bungsaufgabe bezieht sich nur auf die Abstimmung zwischen den Controllern und die Ansteuerung der Roboter.
Daher ist es notwendig, ein Interface ins "Innere" der Simulation bereitzustellen, das dann von den Studenten genutzt wird.
