\clearpage
\section{Einf{\"{u}}hrung}
\begin{figure}
	\centering
	\includevisio[width=\textwidth]{simulation}
	\caption{Screenshot der Simulation}
	\label{fig:simulation}
\end{figure}

\subsection{Motivation} Seit der Einf{\"{u}}hrung der Computer und vor allem seit dem rasanten Wachstums des
Internets, werden Computer in immer mehr Bereichen eingesetzt. Es gibt nur noch wenige Berufe oder 
Freizeitaktivit{\"{a}}ten die komplett ohne auskommen; Die Buchhaltung geschieht komplett elektronisch und
das Geld wird elektronisch {\"{u}}berwiesen, anstatt in einer Lohnt{\"{u}}te ausgeh{\"{a}}ndigt zu werden.
Und um herauszufinden ob der Lohn angekommen ist benutzt man Onlinebanking, wobei eine
unm{\"{o}}glich absch{\"{a}}tzbare Anzahl an vernetzten Computern beteiligt ist. Auch komplett ohne Technik
durchf{\"{u}}hrbare Freizeitaktivit{\"{a}}ten wie das Kegeln sind heute ohne Computerunterst{\"{u}}tzung
kaum noch vorstellbar --- in den Kegelbahnen z{\"{a}}hlt ein Computer f{\"{u}}r jeden Spieler mit wie viele
Punkte erreicht wurden und stellt die umgeworfenen Kegel automatisch wieder auf.

Dies bietet enorme, jeden Tag ersichtlich werdene Vorteile, birgt jedoch auch Risiken. Die Komplexit{\"{a}}t,
oder den Aufwand, die der "Nutzer" bew{\"{a}}ltigen muss, sinkt zwar (meistens), allerdings wird das
System fehleranf{\"{a}}lliger. Es gibt mehr Komponenten, also kann mehr kaputt gehen.

Zu einem Problem wird dies falls es um lebenswichtige Bereiche wie die
Strom- und Wasserversorgung, Fahrassistenz und {\"{a}}hnliches geht. Auch kleine Fehler dort k{\"{o}}nnen
enorme Konsequen haben. 

Wie man an \todo{a, b, und c} sieht, wird dieser Aspekt oft vernachl{\"{a}}ssigt. Oftmals ist es am wichtigsten den
Projektzeitplan einzuhalten, und gerade nicht-funktionalen Eigenschaften geniessen keine hohe Priorit{\"{a}}t da M{\"{a}}ngel
bei diesen dem Kunden nicht unbedingt auffallen. Erschwerend kommt hinzu das oft auch einfach das Problembewusstsein oder auch nur die
n{\"{o}}tigen Grundlagen fehlen um System wirklich ausfallsicher zu machen.

\subsection{Aufgabenstellung} In dem Modul "Ausfallsichere Systeme" soll den Studenten beigebracht werden wie sie ausfallsichere Systeme
designen und implementieren k{\"{o}}nnen, um gerade solche Probleme zu vermeiden. Daf{\"{u}}r gibt es einen theoretischen (die Vorlesung) und
einen praktischen Teil (eine {\"{U}}bungsaufgabe). Die {\"{U}}bungsaufgabe soll eine M{\"{o}}glichkeit geben das theoretische Wissen anzuwenden.
Dabei werden die Studenten aus den gelernten Techniken die richtigen f{\"{u}}r die Aufgabe heraussuchen m{\"{u}}ssen, diese gegen Alternativen
abw{\"{a}}gen und sie dann zu implementieren. Durch die praktische Anwendung wird das gelernte wiederholt und vertieft, was zu einem besseren
Verst{\"{a}}ndnis f{\"{u}}hrt.

Die Aufgabe dieser Bachelorarbeit ist die Konzeption der selbigen. Zus{\"{a}}tzlich soll das fertige Produkt auch im Rahmen von Informationsveranstaltungen als Demonstrationsprojekt
nutzbar sein und gerade auch Menschen ohne Fachkentnisse einen Einblick in die Komplexit{\"{a}}t ausfallsicherer Systeme geben, dabei aber trotzdem interessant
sein.

Dies f{\"{u}}hrte zur Idee eine Computersimulation zu entwickeln. Diese kann visuell ansprechend sein und bieten vielf{\"{a}}tige Interationsm{\"{o}}glichkeiten.

\subsection{Gliederung} Diese Bachelorarbeit besteht aus zwei Teilen. Im ersten wird die Aufgabenstellung entwickelt, im zweiten der L{\"{o}}sungsweg skizziert.

Der erste Teil besteht aus einer Einf{\"{u}}hrung, um den Sinn und Zweck dieser Arbeit zu verdeutlichen. Danach wird erkl{\"{a}}rt, warum die
\hyperref[heizung]{existierende {\"{U}}bungsaufgabe} nicht ausreicht; basierend darauf werden die Anforderungen an die neue Aufgabe entwickelt.

Im zweiten Teil werden als erstes die ben{\"{o}}tigten Grundlagen zur Umsetzung erkl{\"{a}}rt. Dabei geht es einerseits um mechanische und physische Konzepte wie das
\hyperref[diffs]{\textit{differential steering}} und die mathematische Grundlagen der Vektorrechnung, aber auch um Informationstechnologische Aspekte wie die Serialisierung von Daten oder
verschiedene Netzwerkkommunikationsarten. Darauf aufbauend wird dann die Implementierung beschrieben, mit besonderem Fokus auf dem Fehlermodell und der
Fehlerinjektion.

Zum Schluss wird die Simulation anhand der Kriterien evaluiert und ein Fazit gezogen.

\clearpage
\section{Die ausfallsichere Heizung}\label{heizung}
Eine {\"{U}}bungsaufgabe im Module Ausfallsichere System wurde im Sommersemester 2016 an der FH S{\"{u}}dwestfalen entwickelt. Das Ziel ist es, mithilfe zwei Heizk{\"{o}}rpern, zweier
L{\"{u}}fter, einer Klappe und mehrer Temperatursensoren eine Temperatur zu regeln. F{\"{u}}r die Regelung m{\"{u}}ssen sich drei Rechner abstimmen, den einer kontrolliert
beide Heizungen, einer beide L{\"{u}}fter und der dritte die Klappe. Um sich abzustimmen k{\"{o}}nnen die Rechner {\"{u}}ber UDP und I\textsuperscript{2}C miteinander kommunizieren.

Das Gesamtsystem ist Y-f{\"{o}}rmig aufgebaut; an den Armen des Ypsilon befindet sich jeweils ein Heizk{\"{o}}rper und ein L{\"{u}}fter, an dem Punkt, an dem sich
die Arme treffen, ist die Klappe, die den Luftstrom eines Arms ganz oder teilweise blockieren kann (diese Luft wird dann nach oben abgeleitet).

Um die Temperaturen in den Armen und die Temperatur des Luftstromes zu messen gibt es Temperatursensoren. Jeweils ein Temperatursensor im Luftausgangsstrom ist einem
der Rechner zugeordnet. Zus{\"{a}}tzlich hat der L{\"{u}}ftungsrechner einen Temperatursensor pro Arm zwischen L{\"{u}}fter und Heizung, und der Heizungsrechner jeweils
einen Temperatursensor vor der Heizung.

\begin{figure}
	\centering
	\includevisio[width=\textwidth]{HeizungHW}
	\caption{Aktoren und Sensoren der Heizung}
	\label{fig:heizunghw}
\end{figure}

\subsection{XXX Benutzung? Gebrauch? Fehlermodell?}
All diese Bestandteile k{\"{o}}nnen auf verschiedene Arten fehlerhaft sein, die Aufgabe der Studierenden ist es sich f{\"{u}}r die verschiedenen Fehlerkombinationen
geeignete Strategien auszudenken um die Auswirkungen zu minimieren.

Beispielsweise kann es vorkommen das ein Heizk{\"{o}}rper ausf{\"{a}}llt, also sich nicht weiter aufheizen kann. Dies muss erst einmal erkannt werden, zum Beispiel
durch den Vergleich des Soll-wertes der Heizungsansteuerung und den Temperaturen vor und hinter der Heizk{\"{o}}rper. Falls diese Temperaturen gleich sind,
wurde die Luft die vom L{\"{u}}fter Richtung Ausgang bewegt wurde, nicht aufgew{\"{a}}rmt, ergo heizt dieser Heizk{\"{o}}rper nicht. Dann k{\"{o}}nnen sich die
Rechner abstimmen wie sie die Temperatur trotzdem ansteigen lassen k{\"{o}}nnen, zum Beispiel ob der {\"{u}}brig gebliene Heizk{\"{o}}rper st{\"{a}}rker heizen
soll, oder ob dieser weniger gek{\"{u}}hlt werden soll.

{\"{A}}hnlich ist es bei einem Ausfall der L{\"{u}}fter. Auch Doppelfehler sind m{\"{o}}glich, also das eine L{\"{u}}ftung und ein Heizk{\"{o}}rper ausfallen. Falls
dies in unterschiedlichen {\"{A}}rmen passiert, kann sich ein Arm {\"{u}}berhitzen und besch{\"{a}}digt werden.

Auch die Kommunikationswege k{\"{o}}nnen ausfallen. Was passiert wenn der Heizungsrechner nicht mehr erreichbar ist, aber eine Heizung weniger stark heizen soll?
Da es zwei Kommunikationswege gibt, kann normalerweise UDP/IP f{\"{u}}r die Kommunikation verwendt werden und I\textsuperscript{2}C nur
als \textit{passive backup? cold standby?}. Oder einen {\"{U}}bertragungsweg nur f{\"{u}}r Daten und den anderen um zu signalisieren das dieser Rechner noch das
Steuerprogramm ausf{\"{u}}hrt, wodurch erkannt werden kann das der Daten{\"{u}}bertragungsweg ausgefallen ist.

Als letztes k{\"{o}}nnen auch die Temperatursensoren ausfallen. Im Luftausgangsstrom, wo drei Sensoren nebeneinander angeordnet sind, ist es m{\"{o}}glich den
Ausfall eines Sensors anhand der Diskrepanz der Messergebnisse aller Sensoren zu erkennen. Eine m{\"{o}}gliche Strategie um die Ausgangstemperatur zu
bestimmen w{\"{a}}re also die \textit{triple modular redudancy} auszunutzen und den Mittelwert aller nicht klar als fehlerhaft erkennbaren Sensoren zu bilden.
Es ist auch denkbar die vorherigen Messwerte zu benutzen um, anhand unrealistischer Spr{\"{u}}nge der Messwerte, zu erkennen das ein Sensor einen fehlerhaften
Messwert geliefert hat.

Nat{\"{u}}rlich ist es auch denkbar das mehrere dieser Fehler auftreten, also beispielsweise f{\"{a}}llt erst ein Sensor, dann das Netzwerk aus und danach
steckt die Klappt fest.

\subsection{Evaluation} Dadurch das die Heizungen eine beschr{\"{a}}nkte Leistung haben und eine gro{\ss}e Menge Luft ($ \approx (15*15*50)cm^3$) aufheizen muss,
ist die Regelung sehr tr{\"{a}}ge. Damit ist es als Vorf{\"{u}}hrobjekt zum Beispiel f{\"{u}}r Schulklassen ungeeignet, diese k{\"{o}}nnen nicht 10 Minuten warten
bis die Temperatur eingeregelt wurde, dann ein Fehler injeziert wurde (zum Beispiel eine Heizung ausf{\"{a}}llt), dieser Ausfall erkannt wird und dann gegengesteuert
wurde.

Desweiteren gibt es dieses System nur einmal. Das bedeutet einerseits das es bei gro{\ss}en Gruppen an Sch{\"{u}}lern unm{\"{o}}glich wird das alle etwas
f{\"{u}}hlen k{\"{o}}nnen und andererseits, es durch die lange Regelzeit zu Koordinationsproblemen kommt. W{\"{a}}hrend eine Gruppe ihr Programm testet m{\"{u}}ssen
alle anderen Gruppen warten. Da fast jeder Test mehrere Minuten dauert, verbringen die Gruppen die allermeiste Zeit mit warten und nur wenig Zeit mit produktiver
Arbeit.

\clearpage
\section{Anforderungen}\label{anforderung}
Aus den Schwachstellen der vorhanden L{\"{o}}sung l{\"{a}}sst sich ableiten, was das neue System leisten soll:
\begin{enumerate}
	\item Die Alternativaufgabe soll sich stark von der ausfallsicheren Heizung unterscheiden, damit die Studierenden eine tats{\"{a}}chliche Wahl haben.
	\item Es muss m{\"{o}}glich sein mehrere Instanzen gleichzeitig laufen zu lassen. Damit werden die Koordinierungsprobleme vermieden.
	\item In dem neuen System muss die Fehlerinjektion parametrisierbar sein. Damit ist es m{\"{o}}glich
		die Aufgabe bei Bedarf zu vereinfachen oder zu verkomplizieren, zum Beispiel in dem bestimmte
		Arten der Fehlerinjektion ganz auschgeschaltet werden.
	\item Um die Aufgabe zu l{\"{o}}sen, muss eine Vielzahl von Konzepten der Ausfallsicherheit genutzt werden.
	\item Es soll visuell ansprechend sein.
	\item Es darf auch durch unsachgem{\"{a}}{\ss}en Gebrauch nicht gesch{\"{a}}digt werden
\end{enumerate}

\clearpage
\section{Die balancierenden Roboter}
An der Humboldt Universit{\"{a}}t Berlin (in Zusammenarbeit mit Daimler Benz) wurde eine Simulation\cite{Werner00} entwickelt. In der Simulation soll
eine simulierte Platte durch die Bewegung von simulierten Robotern auszubalanciert werden. Das Gewicht jedes Roboters wirkt auf die Platte, bringt sie also aus dem Gleichgewicht.
Die Roboter m{\"{u}}ssen sich nun so
bewegen, dass jede durch einen Roboter ausge{\"{u}}bte Kraft von einem anderen Roboter eliminiert wird. Damit es nicht m{\"{o}}glich ist, einmal eine Stellung einzunehmen,
die zum Gleichgewicht f{\"{u}}hrt und dort zu verharren, haben die Roboter einen Energiespeicher, der mit der Zeit leerer wird. Da die Roboter sich nur bewegen k{\"{o}}nnen
solange sie noch Energiereserven haben, m{\"{u}}ssen sie hin und wieder diesen Speicher an einer Ladestation auff{\"{u}}llen.

Das Ziel dieser Simulation war zu demonstrieren das auch in Echtzeitsystem eine Konsensfindung m{\"{o}}glich ist. Fall ein Ergebniss durch
\textit{triple modular redudance} und einen Voter bestimmt werden soll, verh{\"{a}}hlt sich die naive Implementation im Falle eines \textit{timing faults} so das die
Einhaltung der Echtzeitanforderungen nicht mehr garantiert werden kann. 

Die Simulation und die Controller wurden in Objective-C geschrieben und laufen auf dem NeXTStep Betriebssystem und kommunizieren {\"{u}}ber CORBA miteinander\cite{predictablecorba},
w{\"{a}}hrend das Anzeigeprogramm Java basiert ist und z.B. auf einem Windowsrechner laufen kann.

\paragraph{Evaluation} Die Einarbeitung in COBRA k{\"{o}}nnte vom tats{\"{a}}chlichen Lernstoff ablenken und das ganze unn{\"{o}}tig verkomplizieren; da COBRA auch nur noch
wenig genutzt wird, ist der Mehraufwand nicht zu rechtfertigen. Des weiteren ist das physikalische Modell der Simulation sehr rudiment{\"{a}}r:
die Roboter k{\"{o}}nnen sich holonomisch, also ohne Limitationen in alle Richtungen, bewegen. Dies ist aber bei den meisten Robotern nicht
der Fall, diese haben auf Grund ihres Aufbaus bestimmte Limitationen. Zum Beispiel ist es un{\"{u}}blich, dass sich Roboter vertikal frei bewegen k{\"{o}}nen. Des weiteren
gibt es in der Simulation keine mechanischen Gleichgewichte --- auch dies eine unrealistische Vereinfachung gegen{\"{u}}ber der echten Welt.

Da das Simulationsprogramm in den Neunzigern auf NeXTStep Rechnern entwickelt wurde, l{\"{a}}uft es auch nur auf diesen. Leider existieren solche Rechner in der Fachhochschule
S{\"{u}}dwestfalen nicht, das Programm m{\"{u}}sste also erst portiert werden.

Aus all diesen Gr{\"{u}}nden wurde entschieden eine neue {\"{U}}bungsaufgabe zu entwickeln.

\clearpage
\section{Simulationsidee}
Die simulierte Welt besteht aus einer kreisf{\"{o}}rmigen Platte. Auf dieser k{\"{o}}nnen bis zu \gls{N} Roboter und $1$ F{\"{u}}llstation (\gls{F})
platziert werden. Die Summe alle Gewichte kippt die Platte; sind die Gewichte zu ungleichm{\"{a}}{\ss}ig verteilt, kippt
die Platte um und die Simulation endet.

Die Roboter k{\"{o}}nnen sich frei auf der Platte bewegen, verbrauchen dabei aber Energie und m{\"{u}}ssen diese dann irgendwann
an der F{\"{u}}llstation auff{\"{u}}llen. Auch wenn die Roboter sich nicht bewegen, verbrauchen sie Energie (allerdings weniger
schnell).

Gesteuert werden die Roboter von bis zu \gls{M} $(M \geq N)$ Controllern. Einer oder mehr Controller stimmen sich ab,
so dass:
\begin{itemize}
\item die Roboter ihre Energie immer rechtzeitig auff{\"{u}}llen
\item die Roboter nicht kollidieren
\item die Platte nicht kippt
\end{itemize}

Dieser Abstimmungsvorgang sollte fehlertolerant implementiert werden, so dass auch beim Ausfall eines (oder mehrerer) Controller die Roboter sich immer noch koordiniert bewegen.
(Abh{\"{a}}ngig vom Verh{\"{a}}ltnis der Anzahl der Controller zur Anzahl der Roboter k{\"{o}}nnen verschiedene Stufen der Fehlertoleranz erreicht werden.\cite[s.149]{Werner00})

Die Voter und Controller laufen auf Virtuellen Maschinen, jeweils eine VM pro Voter- oder Controllerinstanz.
Diese VMs befinden sich in einem Netzwerk, dass durch eine Fehlerinjektion UDP Pakete verf{\"{a}}lscht --- dies simuliert ein fehlertr{\"{a}}chtiges Netzwerk wie es zum Beispiel bei Funknetzwerken der Fall ist.
Es wird vorgegeben, dass die gesamte Kommunikation {\"{u}}ber UDP stattfinden muss. Die Kommunikation von Simulation zu den Votern ist davon nicht betroffen, sie soll nicht verf{\"{a}}lscht werden.

\begin{figure}
	\centering
	\includevisio[width=\textwidth]{Netzwerk}
	\caption{Aufteilung der Netzwerkteilnehmer}
	\label{fig:network}
\end{figure}

Zusammenfassend besteht das ganze System aus diesen Teilen:
\begin{itemize}
	\item Die Simulation berechnet die Bewegungen und implementiert das physikalische Modell. Sie {\"{u}}bernimmt auch die Visualisierung. Per Definition ist sie ausfallsicher.
	\item Der Voter sammelt die Steuerkommandos von den Controllern, bildet daraus das Steuerergebniss und sendet dies an die Simulation. Er ist per Definition ausfallsicher gegen \textit{crash failures}.
	\item Die Controller generieren Steuerkommandos. Sie k{\"{o}}nnen jederzeit ausfallen.
\end{itemize}

\paragraph{Nutzung durch die Studenten} Von den Studierenden muss nicht die gesamte Simulation erstellt werden; die {\"{U}}bungsaufgabe bezieht sich nur auf die Abstimmung zwischen den Controllern und die Ansteuerung der Roboter.
Daher ist es notwendig, ein Interface ins "Innere" der Simulation bereitzustellen, das dann von den Studenten genutzt wird.
