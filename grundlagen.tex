\clearpage
\section{Physiksimulation}
\todo{einleitung}

\subsection{Bewegungsmuster}
Die simulierten Roboter sind an den Kepheraroboter angelehnt, einen gerade im unitversit{\"{a}}ren Bereich weit verbreiteten Roboter mit 2 Motoren und 2 starren R{\"{a}}dern.
Dies gibt auch das Bewegungsmodell vor: \hyperref[diffs]{\textit{differential steering}}, auch \textit{differential drive} genannt. Ausf{\"{u}}hrlicher wird dies im zugeh{\"{o}}rigen Unterkapitel erkl{\"{a}}rt.

\begin{figure}
	\centering
	\includevisio{k4-detail1.png}
	\caption{Der Khepera IV Roboter}
	\label{fig:kheperaiv}
\end{figure}
\clearpage

\subsubsection{Differential Steering}\label{diffs}
Beim \textit{differential steering} k{\"{o}}nnen die R{\"{a}}der nicht, wie z.B. beim Auto, geschwenkt werden -- sie sind fest. Eine Rotation wird durch eine unterschiedliche Rotationsgeschwindigkeit der R{\"{a}}der
erm{\"{o}}glicht; bekannt ist dieses Prinzip vom Rollstuhl. Es kann zwischen drei Bewegungsarten unterschieden werden:
\begin{itemize}
\item Falls die R{\"{a}}der gleich schnell drehen, f{\"{a}}hrt der Roboter gerade nach vorne oder hinten.
\item Falls die R{\"{a}}der unterschiedlich schnell, aber in die gleiche Richtung rotieren, wird eine Kurve gefahren. Dabei dreht sich der Roboter in Richtung des langsamer rotierenden Rades.
\item Falls die R{\"{a}}der gleisch schneller, aber in unterschiedliche Richtunge rotieren, wendet der Roboter auf der Stelle.
\end{itemize}

Diese Bewegungen k{\"{o}}nnen auch mathematisch ausgedr{\"{u}}ckt werden. Dabei gibt $V_r(t)$ die Rotationsgeschwindigkeit des rechten Rades zum Zeitpunkt t an, w{\"{a}}hrend $V_l(t)$ das
linke Rad beschreibt. \gls{R} ist der Radius eines Rades, und \gls{L} die Distanz zwischen den R{\"{a}}dern.
Folgende Gleichungen aus \cite{Dudek2010, Egerstedt}:
\begin{subequations}\label{eq:diffs}
\begin{align}
	\Theta(t) &= \Theta(0) + \frac{R}{L} \int_0^t \mathrm{v_R(t) - v_L(t)}\mathrm{d}t \label{eq:diffs-theta}\\
\intertext{Mithilfe der Orientierung zum Zeitpunkt $t$ ist es m{\"{o}}glich die "Fahrtrichtung" zum
	Zeitpunkt $t$ zu bestimmen. Eine Multiplikation dieser mit den Geschwindigkeitsvektoren ergibt den
	Bewegungsvektor zum Zeitpunkt $t$ - daraus l{\"{a}}sst sich die Position ermitteln:
}
	x(t) &= x(0) + \frac{1}{2} \int_0^t \mathrm{\big(v_R(t) + v_L(t)\big) \times \cos\big(\Theta(t)\big)}\mathrm{d}t \label{eq:diffs-x}\\
	y(t) &= y(0) + \frac{1}{2} \int_0^t \mathrm{\big(v_R(t) - v_L(t)\big) \times \cos\big(\Theta(t)\big)}\mathrm{d}t \label{eq:diffs-y}
\end{align}
\end{subequations}

\subsubsection{Wegfindung}
Da ein \textit{differential steering} Roboter sich nicht-holonomisch (ohne Beschr{\"{a}}nung auf allen Achsen) bewegen kann, wird die Wegfindung
erschwert. Zur L{\"{o}}sung dieses Problems (auch bekannt als inverses kinematisches Problems) k{\"{o}}nnte der Roboter sich erst auf der Stelle
drehen, bis er das Ziel "anguckt" und sich dann gradlienig auf dieses zubewegen.

Falls einer der beiden Robotermotoren allerdings nicht vollst{\"{a}}ndig funktionst{\"{u}}chtig ist, ist dies nicht m{\"{o}}glich. Eine m{\"{o}}gliche
Alternative w{\"{a}}hre es eine Kurve zu fahren, dies muss allerdings -- abh{\"{a}}ngig von der zur{\"{u}}ckzulegenden Strecke -- nicht immer m{\"{o}}glich
sein.

\subsection{Physiksimulation der Platte}
Das zu erreichende Ziel ist es die Platte m{\"{o}}glichst "still" in einem Gleichgewicht zu halten, also
die Kippwinkel und die {\"{A}}nderungsrate des Kippwinkels zu minimieren.

Dabei ist der Kippwinkel abh{\"{a}}ngig von der Verteilung der Gewichte auf der Platte, w{\"{a}}hrend die
{\"{A}}nderungsrate von den auf die Platte wirkenden Kr{\"{a}}ften abh{\"{a}}ngt. Diese beiden Unterscheidungen
werden in den nachfolgenden Kapiteln behandelt.

\subsubsection{Statisches Gleichgewicht}
Die Platte ist im statischen Gleichgewicht wenn alle Kr{\"{a}}fte/Gewichte (der Objekte, also der F{\"{u}}llstation und aller Roboter) die auf sie wirken, sich zu Null aufaddieren.
Dabei werden die Objekte als Vektoren bestehend aus Gewicht und Abstand zum Mittelpunkt betrachtet.

Um das Kippen der Platte auf der links-rechts und vorne-hinten Achse getrennt angeben zu k{\"{o}}nnen, werden diese getrennt voneinander ausgerechnet. Dabei wird das Hebelgesetz
im eindimensionalen Fall (wie auf einer Wippe) angewandt, also Distanz mal Masse ergibt die Kraft in dieser Richtung
\footnote{Da die Positionsbestandteile (x und y) einzeln betrachtet werden, muss der Winkel nicht in die Rechnung einflie{\ss}en}.

F{\"{u}}r die in Links-Rechts wirkende Kr{\"{a}}fte gilt Gleichung ~\ref{eq:forces:x}, f{\"{u}}r die Kr{\"{a}}fte die beschreiben wie die Platte nach vorne-hinten gekippt
gilt Gleichung ~\ref{eq:forces:y}.
\begin{subequations}\label{eq:forces}
\begin{align}
	V(x) = x(F) \times w(F) + \sum_{i=0}^{|\gls{N}|} ( x(N_i) \times w(N_i) ) \label{eq:forces:x}\\
	V(y) = y(F) \times w(F) + \sum_{i=0}^{|N|} ( y(N_i) \times w(N_i) ) \label{eq:forces:y}
\end{align}
\end{subequations}

Das Ziel ist es die Platte auszubalancieren, also soll gelten:
\begin{equation}\label{eq:gleichgewicht}
	V(x) = V(y) = 0
\end{equation}

\subsubsection{Kippwinkel}
\todo{woanders hinbewegen. ist eher implementation}
Diese Kr{\"{a}}fte f{\"{u}}hren dazu das die Platte kippt. Es ist definiert das der maximale Kippwinkel von 10\textdegree erreicht wird, falls sich alle
Objekte (also vollgetankte Roboter und Ladestation) am {\"{a}}ussersten Rand der Platte befinden. Um den momentanen Kippwinkel zu ermittelen werden nun
die momentan wirkenden Kr{\"{a}}fte mit den maximal m{\"{o}}glichen Kr{\"{a}}ften verrechnet; dies geschieht mit einem simplen Dreisatz:

\begin{align}\label{eq:tilt-from-maxtilt}
10\degree = Max, X\degree = Curr \\
\Rightarrow \frac{Max}{Curr} = \frac{10}{X} \\
\Rightarrow \frac{1}{X} = \frac{Max}{10 \times Curr} \\
\Rightarrow X = \frac{10 \times Curr}{Max}
\end{align}

\subsubsection{Dynamischen Gleichgewicht}
Eine Geschwindigkeits{\"{a}}nderung der Roboter erzeugt einen Impuls, auch dieser wirkt auf die Platte. Die Energie des Impulses ist proportional zur
{\"{A}}nderung und schwingt dann langsam ab. Da ein geschlossenes System simuliert wird, ist dem Impuls eine gleich gro{\ss}e Kraft entgegen gerichtet.
Diese beiden Kr{\"{a}}fte f{\"{u}}hren zu einer (abklingenden) Schwingung. Mathematisch ausgedr{\"{u}}ckt:
\begin{equation}\label{eq:schwingung}
	s(t) = e^\mathrm{-\delta t} \times sin(\omega_d t) \times s(0)
\end{equation}
\cite{wiki:schwingung}
\footnote{$\delta$ und $\omega_d$ sind in der Simulation frei einstellbar}

Hierbei ist $s(t)$ ein Vektor, in dem die Geschwindigkeits{\"{a}}nderung in X-, Y- und Z-Richtung die jeweiligen Elemente sind. Um die gesamte Schwindung der
Platte zu bestimmen werden die Ergebnissvektoren der einzelnen Roboter aufaddiert.

\clearpage
\section{Das zu simulierende Fehlermodell}\label{fm}
Das Ziel der Aufgabe ist es, Studierenden etwas {\"{u}}ber ausfallsichere Systeme beizubringen. Daf{\"{u}}r
muss auch etwas ausfallen, denn nur dann wird getestet ob die Auswirkungen des Ausfalls abgemindert werden 
konnten.

Im Fehlermodell wird festgelegt, was alles -- und auf welche Weise -- ausfallen kann. Dabei wird f{\"{u}}r jeden Bestandteil der Simulation ein eigenes Fehlermodell aufgestellt. Die Bestandteile
der Simulation sind hier die simulierte Welt mit ihren Robotern (und den dazugeh{\"{o}}rigen Motoren/Aktoren
und Sensoren), die Kommunikationswege zwischen Voter und Controller und die Controller selbst.

\subsection{Roboter / Motoren}
Die simulierten Roboter {\"{a}}hneln dem Khepera Roboter und haben daher 2 Motoren. Diese beiden Motoren k{\"{o}}nnen unabh{\"{a}}ngig von einander fehlerhaft sein. Fehlerhaft
hei{\ss}t hier:
\begin{itemize}
	\item Die H{\"{a}}ufigkeit von Hardwarefehler wird oft mithilfe der Badewannenkurve modelliert. Sie besagt,
		dass Hardware entweder kurz nach Inbetriebnahme oder nach langer Betriebszeit mit hoher
		Wahrscheinlichkeit fehlerhaft ist, und in der Zwischenzeit nur mit niedriger Wahrscheinlichkeit.
		F{\"{u}}r die Motoren der Roboter wird ein vereinfachtes Modell genutzt, in dem die Wahrscheinlichkeit 
		f{\"{u}}r einen Ausfall bis zu einer bestimmten Betriebslaufzeit einstellbar ist und danach auf
		Null sinkt. Falls der Motor in dieser Zeit Fehler aufweist, bleibt diese Fehler auch.
	\item Desweiteren kann ein Motor tempor{\"{a}}r ein \textit{stuck-at}-Verhalten aufweisen. Dieses
		kann jederzeit passieren und entweder tempor{\"{a}}rer oder permament sein.
		Die Wahrscheinlichkeiten f{\"{u}}r das Auftreten eines permamenten oder tempor{\"{a}}ren
		\textit{stuck-at}-Fehlers sind unabh{\"{a}}ngig voneinander einstellbar.
\end{itemize}

Da jeder der \gls{N} Roboter 2 Motoren hat, k{\"{o}}nnten theoretisch auch 2 Motoren kaputt gehen. Ein Roboter mit einem fehlerhaften Motor kann allerdings immernoch sinnvoll genutzt werden,
bei einem Roboter mit 2 fehlerhaften Motoren ist dies nicht der Fall. Es soll m{\"{o}}glich sein verschiedene 
Schwierigkeitsstufen der Simulation einzustellen. Daher ist es m{\"{o}}glich
dass nur ein Motor pro Roboter gleichzeitig Fehler aufweisen kann.

Aus dem gleichen Grund ist es parametresierbar, wie viele Roboter gleichzeitig irgendeine Art von Fehler aufweisen k{\"{o}}nnen.

Zus{\"{a}}tzlich zu diesen Fehler soll es auch m{\"{o}}glich sein, einen Roboter fernzusteuern. W{\"{a}}hrend
der Fernsteuerung darf dieser Roboter keine Steuerbefehle seines Voters ausf{\"{u}}hrend sondern wird rein
vom Nuter gesteuert. Diese Art der Fehlerinjektion w{\"{u}}rde in Richtung byzantinische Fehler gehen,
denn dies w{\"{u}}rde es erm{\"{o}}glichen, gezielt die Platte zu destabilisieren oder Roboter zu
blockieren.

\subsection{Weltstatusinformationen}
Die Roboter haben ihre Aktoren, um sich in der Welt zu bewegen. Damit sie sich sinnvoll bewegen und die
Platte balanciert k{\"{o}}nnen, brauchen sie Informationen {\"{u}}ber den Status der Welt und ihre
(und die der anderen Roboter) Position in dieser. Diese Informationen sind direkt verf{\"{u}}gbar
und m{\"{u}}ssen nicht, zum Beispiel odeometrisch, erst herausgefunden werden. In der realen Welt sind
Sensoren, wie sie hier vielleicht h{\"{a}}tten simuliert werden k{\"{o}}nnen, nat{\"{u}}rlich manchmal 
fehlerbehaftet. Um dies nachzubilden k{\"{o}}nnen, die Informationen {\"{u}}ber den Weltstatus auf
verschiedene Arten fehlerhaft an den Roboter weitergeleitet werden.

Als erstes ist es m{\"{o}}glich, dass der Roboter einfach keinerlei Informationen mehr bekommt, also ein \textit{omission failure} vorliegt. Ein \textit{stuck-at} Fehler liegt
vor wenn veralterte Informationen wieder an den Roboter weitergegeben werden, so als w{\"{u}}rde ein Sensor nur noch seine letzen g{\"{u}}ltigen Daten liefern. Der dritte
Fall liegt vor, wenn komplett falsche Daten geliefert werden. Komplett falsch hei{\ss}t, dass die Anzahl und die Positionen, Gewichte etc. der Roboter potenziell fehlerhaft an
den Roboter weitergegeben werden. Die Wahrscheinlichkeiten f{\"{u}}r die jeweiligen F{\"{a}}lle lassen sich unabh{\"{a}}ngig von einander einstellen.

\subsection{Netwerk}
Da die simulierten Roboter den Khepera Robotern {\"{a}}hneln sollen, sollen auch ihre 
Kommunikationsm{\"{o}}glichkeiten denen der Khepera Roboter {\"{a}}hneln. Bei beweglichen
Objekten sind Ethernetkabel suboptimal, weswegen diese Funkverbindungen -- im Falle der Khepera
Roboter ist dies WLAN -- bevorzugen. Funkverbindungen haben aber, im Gegensatz zu gut abgeschirmten
Ethernetkabeln, Probleme mit Interferenzen durch andere Funk{\"{u}}bertragungen.

Dies f{\"{u}}hrt dazu das w{\"{a}}hrend der {\"{U}}bertragung Bits, oder sogar ganze Bytes, verf{\"{a}}lscht werden. Auch die Wahrscheinlichkeit f{\"{u}}r diesen Fall
soll einstellbar sein. Vereinfachend wird hier angenommen das jeweils nur ein Byte pro Paket verf{\"{a}}lscht wird, es gibt also keine \textit{burst errors}.
Es wird angenommen das die meiste Kommunikation zwischen Robotern "in Sichtweite" geschieht, ohne Zwischenstationen und komplexes Routing. In diesem Fall ist
es ist un{\"{u}}blich das Pakete verloren gehen oder zeitverz{\"{o}}gert weitergeleitet werden, daher ist dies nicht Teil des Fehlermodells.

\subsection{Controller}
Es wird davon ausgegangen, dass die Controllerprogramme auf unzuverl{\"{a}}ssiger Hardware, unzuverl{\"{a}}ssigen 
Betriebssystem laufen und fehlerhaft programmiert sind. Daher muss davon ausgegangen werden, dass die
Programme jederzeit abst{\"{u}}rzen k{\"{o}}nnen. Desweiteren kann auch nicht davon ausgegangen werden,
dass die Controllerprogramme das einzige Programm ist, das l{\"{a}}uft; es kann also auch zu Problemen bei
der Resourceverteilung (RAM, CPU Zeit) kommen.

\subsection{Auswirkungen}
Nachdem Fehlermodelle f{\"{u}}r die verschiedenen Elemente des Systems entwickelt wurden, kann
betrachtet werden, welche Auswirkungen die verschiedenen Fehler haben k{\"{o}}nnen. Hierbei werden nur
die Auswirkungen in Bezug auf die Platte betrachtet.

\paragraph{Unkontrollierte Bewegung} Falls sich ein Roboter unkontrolliert bewegt (also ein oder
mehrere Motoren einen \textit{stuck-at}-Fehler und die verbliebenden Motoren gar nicht mehr funktionieren)
kann dieser Roboter nicht mehr genutzt werden um die Platte auszubalancieren.
\begin{figure}
	\centering
	\includevisio[width=\textwidth]{fm_robot}
	\caption{Fehlerbaum: Unkontrollierte Bewegung eines Roboters}
	\label{fig:fault-tree-robot}
\end{figure}
\clearpage

\paragraph{Inkorrekte Bewegungen} Ein Roboter bewegt sich "falsch", wenn seine Bewegung weder die Platte 
ausbalanciert noch dazu gedacht, ist den Energiespeicher aufzuf{\"{u}}llen. Dies kann verschiedene Gr{\"{u}}nde 
haben: Entweder bewegt der Roboter sich unkontrolliert oder er wird falsch angesteuert. Beide F{\"{a}}lle
passieren falls die Controller falsche Steuerkommandos senden, oder theoretisch richtige Steuerkommandos
falsch ausgewertet werden.
\begin{figure}
	\centering
	\includevisio[width=\textwidth]{fm_robot2}
	\caption{Fehlerbaum: Inkorrekte Bewegung eines Roboter}
	\label{fig:fault-tree-robot2}
\end{figure}

\clearpage
\section{Game Engine}
\subsection{Anforderungen}
Die Simulation, vor allem die Bewegung der Roboter, kann besonders gut visuell dargestellt werden.
Auch wenn sich das Geschehen rein auf einer zweidimensionalen Ebene stattfindet, ist eine dreidimensionale
Darstellung ansprechender und wird deshalb vorgezogen.

Diese Darstellung geschieht mithilfe einer \textit{3D Engine}; sie bietet die M{\"{o}}glichkeit Objekte und oft 
auch Lichtquellen und Schattenspiel darzustellen. Anstatt solch eine Engine selbst zu implementieren, wird eine 
vorhandene genommen.

Ein weiterer Teil der Simulation ist die Physiksimulation an sich. Auch diese muss nicht selbst programmiert
werden, es gibt verschiedene fertige. \textit{Game engines} kombinieren \textit{3D Engine} und Physikengine;
aus diesem Grund wird eine \textit{game engine} benutzt um die Simulation zu erstellen. Um die sehr gro{\ss}e 
Auswahl einzuschr{\"{a}}nken, wurden die nachfolgenden Kriterien benutzt.

\paragraph{Kosten} Die 3D Engine muss f{\"{u}}r den nicht-kommerziellen edukativen Gebrauch kostenlos sein.

\paragraph{Plattformunabh{\"{a}}ngigkeit} Die mit der \textit{game engine} entwickelte Simulation muss auch
ohne gro{\ss}en Aufwand auf mehrere System (hier Windows und Linux) portierbar sein.

\paragraph{Einfache Benutzung} Das Hauptkriterium ist die einfache Benutzung. Dies beeinhaltet zum einen die
tats{\"{a}}chliche Nutzung (also: gibt es einen graphischen Leveleditor? Wie kann die Interaktionen zwischen
Objekten gesteuert werden?), zum anderen die Qualit{\"{a}}t der Dokumentation. Und schließlich wie verbreitet diese
\textit{engine} ist, und damit auch wie einfach es ist bei Problemen Hilfestellungen zu bekommen.

Es gibt viele \textit{game engines}, genannt seien hier zum Beispiel Cryengine\ref{cryengine}, Unity, Blender, Source
oder Cube. Bis auf die Cryengine w{\"{a}}hren alle kostenlos; auch die Plattformunabh{\"{a}}ngigkeit ist bei
fast allen gegeben. Doch gerade beim letzten Kriterium stach Unity hervor. Nicht nur gibt es eine sehr gro{\ss}e
Community welche bei Problemen helfen kann, eine gute Dokumentation sondern es ist auch m{\"{o}}glich in bekannten
(normalen) Programmiersprachen die Engine zu steuern. Beispielsweise wird die Unreal Engine mit UnrealScript
programmiert, w{\"{a}}hrend Unity in C\# oder JavaScript programmiert werden kann. Daher baut die Simulation auf
Unity auf.

\subsection{Unity}
Unity ist eine von Unity Technologies entwickelte \textit{game engine}, die 2005 f{\"{u}}r Macintosh entwickelt wurde und in der Zwischenzeit auf 27 Plattformen portiert wurde.

In dieser Arbeit wird es benutzt, um die Welt und die Interaktionen zwischen den Objekten zu simulieren und diese auch anzuzeigen. Mithilfe einer Scriptingschnittstelle kann das Geschehen modifiziert werden, z.B. kann die Welt
abh{\"{a}}ngig von der Position und den Gewichten der Objekt gekippt werden oder die Kamera durch Tastatureingaben bewegt werden.

\subsubsection{Grafikengine}
Die in Unity enthaltene Grafikengine ist eine vollwertige 3D-Grafikengine, die es erm{\"{o}}glicht professionelle Videospiele zu programmieren. In dieser Arbeit wird nur
ein kleiner Teil der Funktionalit{\"{a}}t benutzt; komplexere Features wie die Anzeige von Rauch oder realistischem Wasser sind nicht in der Simulation enthalten.

Notwendig ist es aber, dass die verschiedenen Objekte in der simulierten Welt in 3D zu sehen sind und sich die Kamera bewegen l{\"{a}}sst, um das simulierte Geschehen zu
verfolgen. Dies geh{\"{o}}rt zur Grundfunktionalit{\"{a}}t und muss nicht extra implementiert werden.

\subsubsection{Physikengine}
Ein integraler Teil moderner Videospiele ist eine realistische physikalische Umgebung. Dies wird durch die Physikengine von Unity erm{\"{o}}glicht, die in dieser Arbeit wichtigen Funktionalit{\"{a}}ten sind:

\begin{itemize}
\item die Kollisionserkennung, einerseits um zu bestrafen wenn Roboter in einander fahren,
	und andererseits zur Erkennung des Kontaktes mit der F{\"{u}}llstation
\item die Bewegung der Objekte in der Welt zu simulieren, abh{\"{a}}ngig von ihrem Gewicht und ihrer Geschwindigkeit
\end{itemize}

\subsubsection{Scripting bei Unity}
Alle Elemente der Unity Engine k{\"{o}}nnen vom Programmierer gesteuert werden, daf{\"{u}}r k{\"{o}}nnen
die Skriptsprachen C\#, JavaScript und Boo genutzt werden.\cite{wiki:unity}
Um dies zu erm{\"{o}}glichen ist es aus dem Skript heraus m{\"{o}}glich, alle Eigenschaften
der Objekte \footnote{Dies beinhaltet nicht nur die Roboter und F{\"{u}}llstationen sondern auch die Kamera
oder statische Objekte wie Mauern.} auszulesen und zu manipulieren.

Beispielsweise wurde der F{\"{u}}llstation ein Skript zugeordnet, dass solange ein Objekt mit dieser kollidiert, testet, ob dies Objekt ein Roboter ist, und falls dies der Fall ist,
den Roboter auftankt. Ein anderes Skript bewegt die Kamera abh{\"{a}}ngig von den Tastatureingaben des Benutzers.

Um die Skripte in Unity zu integrieren, m{\"{u}}ssen sie bestimmte Eigenschaften haben. Alle Klassen die von UnityEngine.MonoBehaviour
abstammen und registriert sind werden w{\"{a}}hrend der Berechnung jedes Frames aufgerufen. Der genau Zeitpunkt dieses Aufrufes h{\"{a}}ngt von
der Funktion ab\footnote{Vgl. \cite{unity-exec-order}}, beispielsweise wird Update() genau einmal pro Frame aufgerufen nachdem die Physikengine fertig ist
und Inputevents behandelt wurden. Im Gegensatz dazu kann FixedUpdate() mehrmals oder sogar gar nicht w{\"{a}}hrend der Renderung eines Frames aufgerufen
werden, abh{\"{a}}ngig von der Framerate. Daf{\"{u}}r wird FixedUpdate() vor der Physikengine aufgerufen, {\"{A}}nderungen die in dieser
Funktion vorgenommen werden, haben also schon Auswirkungen auf den momentanen Frame. Desweiteren muss der Klassenname innerhalb einer Datei so
hei{\ss}en wie die Datei selbst.

Da Konstruktor und Dekonstrktor nicht {\"{u}}berschrieben werden k{\"{o}}nnen, gibt es die virtual functions Start() und OnDestroy(). Diese
{\"{u}}bernehmen die Aufgaben des Konstruktor und Dekonstrktors.

Es gibt auch weitere {\"{u}}berschreibare Funktionen, mit denen es m{\"{o}}glich ist sich in verschiedene Zwischenschritte des Renderprozesses
einzuklinken (zum Beispiel OnWillRenderObject, OnPostRender, ...). Das gleiche gilt auch f{\"{u}}r Inputevents (beispielsweise OnMouseMove) und
die Ereignisse der Physikengine (OnCollisionStart(), ...).

\clearpage
\section{Kommunikation}

\subsection{Interaktionsmuster}
In einem verteilten System (wie hier) ist es n{\"{o}}tig das die Kommunikationspartner miteinander kommunizieren.
Dies ist auf verschiedene Arten m{\"{o}}glich, daher werden hier exemplarisch einige dargestellt und daraus eine
Auswahl getroffen um die speziellen Anforderungen dieses Systems zu erf{\"{u}}llen.

\subsubsection{Message Passing}
Beim kommunizieren miteinander werden Informationen ausgetauscht. Die simpelste Art der Kommunikation zwischen
Programmen ist das \textit{message passing}, hierbei schickt ein Kommunikationspartner eine Nachricht die an einen bestimmten anderen
Kommunikationspartner adressiert ist.

Bei diesem Interaktionsmuster ist es die Aufgabe der Programmierer die Nachricht zu interpretieren
(also die {\"{U}}bersetzung in ein verst{\"{a}}ndliches Format, zum Beispiel unter Beachtung der Byte-Reihenfolge) und
basierend auf den ausgetauschten Nachrichten zum Beispiel eine Frage - Antwort Beziehung herzustellen.


\subsubsection{Request-Reply}
Bei einer Kommunikation zwischen zwei Menschen / System, oder allgemeiner: Kommunikationspartnern,
ist meistens so das einer redet, dann die andere Person antwortet. Es gibt also \textit{request}
und \textit{reply}.

Diese Form der Kommunikation ist gut geeignet f{\"{u}} Client-Server Kommunikation wie das
aufrufen von Websites. Allerdings kann diese Art von Kommunikation zu Problemen f{\"{u}}hren falls sich die
Informationen schnell {\"{a}}ndern -- die verschiedenen Clients fragen den Server leicht zeitversetzt an und
agieren dann vielleicht basierend auf leicht unterschiedlichen Informationen.

Um das \textit{Request-Reply} Interaktionsmuster einfacher an die verschiedenen Anforderungen verschiedener
Probleme anzupassen, gibt es die \textit{Remote Procedure Calls} als Spezialisierung des \textit{request-
reply}. Dabei wird versucht die ganze Kommunikation so weit zu verstecken und abstrahieren das es so wirkt
als k{\"{o}}nnten Funktion \textit{remote} (also in einem anderen Programm auf einem anderen Rechner) wie
lokale Funktionen aufgerufen werden. Dies erleichtert die Arbeit der Programmierer enorm, sie m{\"{u}}ssen
sich (im besten Fall) gar keine Gedanken mehr {\"{u}}ber die Kommunikation machen und es werden nur
ohnehin bekannt Sprachkonstrukte (der Aufruf von Funktionen) genutzt.
\footnote{Gerade bei der Programmierung von fehlertoleranten Systemen kann diese Abstraktion allerdings
kontraproduktiv sein. Beispielsweise wird durch die Abstraktion auf einen Funktionsaufruf die M{\"{o}}glichkeit
einen Timeout vorzugeben "verbaut"}

F{\"{u}}r die Programmierenden hat dieses Modell den Vorteil das die Nachricht des anderen Systems schon
interpretiert wurde, es muss also weniger Quellcode selbst geschrieben werden.

\subsubsection{Publish-Subscribe}
Die andere intuitiv verst{\"{a}}ndliche Kommunikationsform ist der Votrag.

Die Simulation muss mit einer nicht vorab bestimmbaren Anzahl von Votern/Robotern arbeiten.
Die Kommunikationspartner k{\"{o}}nnen auch jederzeit ausfallen oder es k{\"{o}}nnen neue hinzukommen.
Eine erste L{\"{o}}sungm{\"{o}}glichkeit w{\"{a}}hre es, die Kommunikation {\"{u}}ber UDP Broadcasts
laufen zu lassen. Dadurch w{\"{u}}rden alle Kommunikationspartner automatisch die Nachricht empfangen, ohne
dass sich der Sender darum k{\"{u}}mmern muss an wen Nachrichten gesendet werden m{\"{u}}ssen. Da die
Voter aber in unterschiedlichen Subnetzen sein k{\"{o}}nnen, ist dies nicht m{\"{o}}glich.

Abhilfe schafft das Publish-Subscribe Kommunikationspattern\cite{pubsub}. Dort gibt es einen Publisher (in
diesem Fall die Simulation) und Subscriber (die Voter/Roboter). Die Subscriber verbinden sich mit dem
Publisher und teilen ihm mit, welche Art von Nachrichten sie interessiert. Der Publisher verteilt dann die
Nachrichten, die zu nicht vorhersehbaren Zeitpunkten kommen, anhand dieser Informationen an alle Subscriber zu denen momentan ein Kontakt m{\"{o}}glich ist.

Dies hat drei gro{\ss}e Vorteile. Es gibt eine r{\"{a}}umliche Trennung, das hei{\ss}t der Publisher muss
nichts {\"{u}}ber die Subscriber (zum Beispiel Anzahl, IP Adresse) und andersrum wissen. Es reicht
wenn beide wissen wo sie sich "treffen" k{\"{o}}nnen. Als zweites gibt es eine zeitliche Trennung zwischen
den Kommunikationspartner -- der Publisher kann Nachrichten verschicken, ohne sich dar{\"{u}}ber Gedanken
machen zu m{\"{u}}ssen wann diese beim Subscriber ankommen, w{\"{a}}hrend es f{\"{u}}r den Subscriber
uninteressant ist wann die Nachricht versendet wurde. Der letze Vorteil ist die Entkoppelung von
Nachrichten{\"{u}}bertragung und den anderen Aufgaben des Programmes. Die Nachrichten werden Daten
von ihrer Herstellung verschickt, das Senden einer Nachricht ist also (aus Sicht des
Publishers) O(1) in Bezug auf die Anzahl der Subscriber. Auch auf Seiten des Subscribers gibt es eine
Asynchronit{\"{a}}t, die empfangen Daten werden mithilfe eines Callback angenommen und blockieren damit
nicht die Abarbeitung dieser Daten.

\begin{figure}
	\centering
	\includevisio{pubsub}
	\caption{Publish-Subscribe}
	\label{fig:pubsub}
\end{figure}
\todo{sieht kacke aus. kleiner und andere Auflösung?}

\subsection{Netzwerklibrary}
Um die Kommunikation zwischen den einzelnen Netzwerkteilnehmern nicht komplett selbst zu implementieren, k{\"{o}}nnen bereits bestehende Netzwerklibraries genutzt werden.
Diese bieten, zum Beispiel, die M{\"{o}}glichkeit an einem entfernten Netzwerkteilnehmer Funktionen aufzurufen oder sich f{\"{u}}r Multicasts anzumelden, auch wenn man in einem anderen
\textit{subnet} ist.

\subsubsection{Anforderungen}
Um verteilte Systeme zu programmieren, bietet sich das RPC Modell an, mit dem auf einem anderen Rechner Funktionen 
aufrufen kann. Da alle Voter/Roboter die gleichen Informationen {\"{u}}ber den Weltstatus empfangen m{\"{u}}ssen um
dann gemeinsam sinnvolle Bewegungen auszuf{\"{u}}hren, diese also von der Simulation an alle gleichzeitig verteilt werden
muss, bietet sich auch das Publish Subscribe Interaktionsmuster an.

Diese beiden Interaktionsmuster k{\"{o}}nnen kombiniert werden; Es gibt allerdings keine Netzwerklibrary, die gleichzeitig beides anbietet.
Da es einfacher ist, auf Publish-Subscribe ein RPC Modell aufzubauen, als andersrum, wird diese Funktionalit{\"{a}}t bei der Auswahl der
Netzwerkbibliothek vorgezogen. Dies ist das Hauptkriterium.

Netzwerkbibliotheken, die in C++ geschrieben wurden, k{\"{o}}nnen zwar (mit einem Interface) auch unter C benutzt 
werden, f{\"{u}}gen dem Programm dann aber "heimlich" die C++ Runtime hinzu. Da die Netzwerkbibliothek nicht
nur im Simulationsprogramm selbst sondern auch im Studenteninterface eingesetzt werden soll, m{\"{u}}sste dann
um alle Eventualit{\"{a}}ten wie zum Beispiel \textit{exceptions} abzuhandeln die Studierenden auch C++
Kentnisse haben. Da dies nicht vorausgesetzt werden kann ist eine rein in C geschriebene Bibliothek vorzuziehen.

\clearpage % make sure the table is, at least, in the right section
\begin{table}[h]
\centering
\begin{tabu}{c | c | c | c | p{5cm}}
	\toprule
	Name & RPC & Publish-Subscribe & C++ Runtimeabh{\"{a}}ngigkeit & andere Sprachen \\
	\midrule
	SunRPC & \checkmark & \xmark & \checkmark & C\#, Java, ... \\
	grpc\cite{grpc} & \checkmark & \xmark & \xmark & C\#, Python, Java, ... \\
	ZeroMQ\cite{zeromq} & \xmark & \checkmark & \xmark & C\#, Python, Java, ... \enquote{40+ languages} \\
	nanomsg\cite{nanomsg} & \xmark & \checkmark & \checkmark & C\#, Python, Java, ... (25 Sprachen) \\
	\bottomrule
\end{tabu}
\caption{Anforderungen an die Netzwerkbibliothek}
\end{table}

Aus dieser vergleichenden Darstellung wird klar, dass nanomsg am besten geeignet ist; auf dessen speziellen Eigenschaften wird nun n{\"{a}}her eingegangen.

\subsubsection{nanomsg}
nanomsg ist eine komplett in C geschrieben Netzwerkbibliothek, mit einer API die der POSIX Socket API gleicht (es wird sich also, zum Beispiel mit nn\_connect() verbunden oder mit nn\_send() gesendet).
Der gro{\ss}e Vorteil von nanomsg sind die implementierten {\"{U}}bertragungsarten. Je nach gew{\"{u}}nschter {\"{U}}bertragungsart wird ein unterschiedlicher Socket erstellt, dieser erlaubt die
Interaktion mit den anderen Netzwerkteilnehmern die auch diese {\"{U}}bertragunsart benutzen.

Beispielhaft wird nun auf einige der genutzten Arten eingegangen.

\paragraph{{\"{U}}bertragungsarten}
\subparagraph{Request-Reply} Die intuitiv verst{\"{a}}ndlichste Art zu kommunizieren ist es eine Frage zu stellen, die dann vom Gegen{\"{u}}ber beantwortet wird. In nanomsg ist dies die request-reply
{\"{U}}bertragungsart.

\clearpage
\section{Serialisierung}
\todo{das ist doch konzeptionell auf einer anderen Ebene als sagen wir mal Game Engine oder Physiksim.? Ist doch im
vergleich dazu unwichtig}

Da das Simulationsprogramm mithilfe der Unity 3D Engine geschrieben werden soll ist die Benutzung von C\#
vorgeschrieben; der Rest der Arbeit (also das Interface f{\"{u}}r die Studenten) soll aber in C geschreiben werden
damit die Studenten nicht um \textit{exceptions} oder andere Spezialf{\"{a}}lle abzuhandeln sich erst in
(beispielsweise) C++ hereinarbeiten m{\"{u}}ssen. Die Verwendung verschiedener Sprachen erschwert alelrdings
die Benutzung eines Bin{\"{a}}rprotokoll -- aus diesem Grund werden die Daten serialisiert.

\todo{warum ueberhaupt binarprotokoll? "Sie nennen hier kaum Anforderungen, sondern sortieren schon aus und
entscheiden - gleiches Problem wie in 11." denke mal das heit die anforderungen klarer herausarbeiten}

\subsection{Anforderungen}
Das wichtigste Auswahlkriterium der Serialsierungslibrary ist, dass es eine C (f{\"{u}}r das Studenteninterface) und eine C\# Version (f{\"{u}}r Unity) gibt.
Desweiteren sollen die serialisierten Nachrichten m{\"{o}}glichst klein sein, um auch nach der Anwendung
eines fehlerkorrigierenden Codes so wenig Redudanz wie m{\"{o}}glich aufzuweisen und damit nur wenig f{\"{u}}r Paketverf{\"{a}}lschungen anf{\"{a}}llig zu sein.

\begin{table}[h]
\centering
\begin{tabu}{c | c | c | c | p{5cm}}
	\toprule
	Name & Wenig Redudanz? & C Version & C\# Version \\
	\midrule
	JSON & \xmark & \checkmark & \checkmark \\
	XML & \xmark & \checkmark & \checkmark \\
	ProtoBuf & \checkmark & \xmark\footnotemark & \checkmark \\
	Msgpack\cite{msgpack} & \checkmark & \checkmark & \checkmark \\
	BSON & \checkmark & \checkmark & \checkmark \\
	\bottomrule
\end{tabu}
\caption{Anforderungen an die Serialisierungsbibliothek}
\end{table}
\footnotetext{Es existieren unoffizielle, nicht mehr weiterentwickelte Implementation} 

Bekannte Serialisierungsformate wie JSON und XML enthalten zu viel Redudanzen und k{\"{o}}nnen ausgeschlossen werden. Zur Auswahl bleiben damit beispielsweise BSON und MsgPack.
Bei BSON werden die Daten an sich effizient serialisiert, allerdings wird immer der Feldname mitgesendet. Dies erleichtert zwar die Versionierbarkeit, vergr{\"{o}}{\ss}ert
die Nachricht allerdings. Aus diesem Grund wird MsgPack als Serialisierungsformat genutzt.

\subsection{MessagePack}
MessagePack ist ein in {\"{u}}ber 50 Sprachen verf{\"{u}}gbares Serialisierungsframework, dessen Nachrichten besonders wenig Redudanzen enthalten sollen. Beispielhaft wird hier auf die Serialisierung von
Integern und Zeichenketten mit fester L{\"{a}}nge eingegangen.

Die Grundpidee von MessagePack ist es Datentypen nicht mit fester Breite sondern nur mit der minmal n{\"{o}}tigen Breite (oder wenigstens einer Ann{\"{a}}hrung an diese) abzuspeichern.
\paragraph{Integer} Da Datens{\"{a}}tze oftmals aus vielen kleinen Integerwerte bestehen, macht es Sinn gerade die Serialsierung dieser zu optimieren. Im Gegensatz zur "normalen" Verarbeitung als immer gleich breite (zum Beispiel 64bit) Zahlen, werden vorzeichenlose Integerwerte kleiner als 128 in einem Byte abgespeichert; der Wert des Bytes entspricht dabei dem Wert des Integers. Dahingegen signalisiert ein gesetztes MSB das es kein (kleiner) Integerwert sondern ein anderer Datentyp ist.
\paragraph{Fixed Size String} Um kleinere Zeichenketten zu encodieren, gibt es erst ein Signalzeichen,
in dem die obersten 3 bits gesetzt sind. Die restlichen 5bits geben die L{\"{a}}nge der Zeichenkette an --
also maximal $2^5 - 1 = 31$ Zeichen. Dies f{\"{u}}hrt zu einem durchschnittlichen Overhead von
$ \frac{1}{\frac{2^5-1}{2}} \approx 6\% $.

L{\"{a}}ngere Zeichenketten werden mit anderen Signalzeichen kodiert, beispielsweise 0xDB f{\"{u}}r eine Zeichenketten mit der Maximall{\"{a}}nge von $(2^{32})-1$ Zeichen.
In diesem Fall folgt die L{\"{a}}ng als 32bit big endian
\footnote{L{\"{a}}ngen werden immer in big-endian, kodiert um den Datenaustausch auch zwischen Rechnern unterschiedlicher Architekturen gew{\"{a}}hrleisten zu k{\"{o}}nen.}
Wert mit fester Breite. Also ein verschwindend geringer durchschnittlicher Overhead von $ \frac{1}{\frac{2^{32}-1}{2}} = 0.00000004\% $.
