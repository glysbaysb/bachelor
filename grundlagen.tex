\clearpage
\section{3D Engine}
\subsection{Anforderungen}
Die Simulation, vor allem die Bewegung der Roboter, kann besonders gut visuell dargestellt werden. Auch wenn sich das Geschehen rein auf einer zweidimensionalen Ebene stattfindet, ist eine dreidimensionale
Darstellung ansprechender und wird deshalb vorgezogen.

Diese Darstellung geschieht mithilfe einer \textit{3D Engine}; sie bietet die M{\"{o}}glichkeit Objekte und oft auch Lichtquellen und Schattenspiel darzustellen.
Anstatt solch eine Engine selbst zu implementieren, wird eine vorhandene genommen.

Um die sehr gro{\ss}e Auswahl einzuschr{\"{a}}nken, wurden die nachfolgenden Kriterien benutzt.

\paragraph{Kosten} Die 3D Engine muss f{\"{u}}r den nicht-kommerziellen edukativen Gebrauch kostenlos sein; dies schliesst, zum Beispiel, die CryEngine\cite{cryengine} automatisch aus.

\paragraph{Plattformunabh{\"{a}}ngigkeit} Die mit der \textit{game engine} entwickelte Simulation muss auf ohne gro{\ss}en Aufwand auf mehrere System (hier Windows und Linux) portierbar sein.

\paragraph{Funktionalit{\"{a}}t} Eine Untermenge der 3D Engines sind \textit{game engines}, diese beeinhalten, zus{\"{a}}tzlich zur reinen 3D Engine, auch eine Physikengine und eine Audioengine.
Durch die Art der Simulation ist ersichtlich, dass eine Physikengine viel Arbeit ersparen k{\"{o}}nnte, gerade im Hinblick auf Beschleunigung, Bewegung oder Kollisionserkennung. Daher werden \textit{game engines} reinen 3D Engines (wie Blender) vorgezogen.

\paragraph{\todo{namen finden}} Das Hauptkriterium ist die einfache Benutzung. Dies beeinhaltet zum einen die
tats{\"{a}}chliche Nutzung (also: gibt es einen graphischen Leveleditor? Wie kann die Interaktionen zwischen
Objekten gesteuert werden?), zum anderen die Qualit{\"{a}}t der Dokumentation und schließlich wie verbreitet diese
\textit{engine} ist, und damit auch wie einfach es ist bei Problemen Hilfestellungen zu bekommen.

Gerade in diesem Punkt stach Unity hervor und wurde deshalb als Basis f{\"{u}}r diese Arbeit ausgew{\"{a}}hlt.

\subsection{Unity}
Unity ist eine von Unity Technologies entwickelte \textit{game engine}, die 2005 f{\"{u}}r Macintosh entwickelt wurde und in der Zwischenzeit auf 27 Plattformen portiert wurde.

In dieser Arbeit wird es benutzt, um die Welt und die Interaktionen zwischen den Objekten zu simulieren und diese auch anzuzeigen. Mithilfe einer Scriptingschnittstelle kann das Geschehen modifiziert werden, z.B. kann die Welt
abh{\"{a}}ngig von der Position und den Gewichten der Objekt gekippt werden oder die Kamera durch Tastatureingaben bewegt werden.

\subsection{Unitys Grafikengine}
Die in Unity enthaltene Grafikengine ist eine vollwertige 3D-Grafikengine, die es erm{\"{o}}glicht professionelle Videospiele zu programmieren. In dieser Arbeit wird nur
ein kleiner Teil der Funktionalit{\"{a}}t benutzt; komplexere Features wie die Anzeige von Rauch oder realistischem Wasser sind nicht in der Simulation enthalten.

Notwendig ist es aber, dass die verschiedenen Objekte in der simulierten Welt in 3D zu sehen sind und sich die Kamera bewegen l{\"{a}}sst, um das simulierte Geschehen zu
verfolgen. Dies geh{\"{o}}rt zur Grundfunktionalit{\"{a}}t und muss nicht extra implementiert werden.

\subsection{Unitys Physikengine}
Ein integraler Teil moderner Videospiele ist eine realistische physikalische Umgebung. Dies wird durch die Physikengine von Unity erm{\"{o}}glicht, die in dieser Arbeit wichtigen Funktionalit{\"{a}}ten sind:

\begin{itemize}
\item die Kollisionserkennung, einerseits um zu bestrafen wenn Roboter in einander fahren und andererseits zur Erkennung des Kontaktes mit der F{\"{u}}llstation
\item die Bewegung der Objekte in der Welt zu simulieren, abh{\"{a}}ngig von ihrem Gewicht und ihrer Geschwindigkeit
\end{itemize}

\subsection{Scripting bei Unity}
Alle Elemente der Unity Engine k{\"{o}}nnen vom Programmierer gesteuert werden, unterst{\"{u}}tzt werden dabei die Skriptsprachen C\#, JavaScript und Boo.\cite{wiki:unity} Um dies zu erm{\"{o}}glichen ist es aus dem Skript heraus m{\"{o}}glich alle Eigenschaften
der Objekte \footnote{Dies beinhaltet nicht nur die Roboter und F{\"{u}}llstationen sondern auch die Kamera oder statische Objekte wie Mauern.} auszulesen und zu manipulieren.

Beispielsweise wurde der F{\"{u}}llstation ein Skript zugeordnet, dass solange ein Objekt mit dieser kollidiert, testet, ob dies Objekt ein Roboter ist, und falls dies der Fall ist,
den Roboter auftankt. Ein anderes Skript bewegt die Kamera abh{\"{a}}ngig von den Tastatureingaben des Benutzers.

\clearpage
\section{RPC}
Der Grundgedanke von verteilten System ist es das die verschiedenen Systeme verschiedene Aufgaben
erledigen. Oft gibt es aber Abh{\"{a}}ngigkeiten zwischen Aufgaben (Aufgabe A muss beendet werden
bevor Aufgabe B angefangen werden kann, zum Beispiel weil das Ergebniss von A f{\"{u}}r B wichtig
ist) oder die Ergebnisse von mehreren System m{\"{u}}ssen zusammengef{\"{u}}hrt werden. Zwischen
den Systemen muss also eine Synchronisation und Kommunikation m{\"{o}}glich sein. Die Kommunikation
an sich kann {\"{u}}ber verschiedene {\"{U}}bertragungsmedien erfolgen, allerdings muss die
Kommunikation an die spezifischen Anforderungen der Applikation angepasst werden. Zum Beispiel
ist die Kommunikation zwischen System die komplexe Wettermodelle berechnen eine andere als die
Kommunikation um Konsistenz zwischen verteilten Datenbankinstanzen herzustellen.\todo{kann ich das einfach
behaupten?}

Abhilfe schaffen \textit{remote procedure call}, mit denen es f{\"{u}}r die verschiedenen Netzwerkteilnehmer
so wirkt als k{\"{o}}nnten sie auf den anderen Netzwerkteilnehmern Funktionen direkt aufrufen.

\todo{tja, ka. irgendwie mehr halt}

\clearpage
\section{Publish-Suscribe}
Die Simulation muss mit einer nicht vorab bestimmbaren Anzahl von Votern/Robotern arbeiten. Die Kommunikationspartner k{\"{o}}nnen auch jederzeit ausfallen oder es k{\"{o}}nnen neue hinzukommen.
Eine erste L{\"{o}}sungm{\"{o}}glichkeit w{\"{a}}hre es die Kommunikation {\"{u}}ber UDP Broadcasts
laufen zu lassen. Dadurch w{\"{u}}rden alle Kommunikationspartner automatisch die Nachricht kriegen ohne
das sich der Sender darum k{\"{u}}mmern muss an wen Nachrichten gesendet werden m{\"{u}}ssen. Da die
Voter aber in unterschiedlichen Subnetzen sein k{\"{o}}nnen ist dies nicht m{\"{o}}glich.

Abhilfe schafft das Publish-Suscribe Kommunikationspattern\cite{pubsub}. Dort gibt es einen Publisher (in
diesem Fall die Simulation) und Suscriber (die Voter/Roboter). Die Suscriber verbinden sich mit dem
Publisher und teilen ihm mit welche Art von Nachrichten sie interessiert. Der Publisher verteilt dann die
Nachrichten, die zu nicht vorhersehbaren Zeitpunkten kommen, anhand dieser Informationen an alle Suscriber zu denen momentan ein Kontakt m{\"{o}}glich ist.

Dies hat drei gro{\ss}e Vorteile. Es gibt eine r{\"{a}}umliche Trennung, das hei{\ss}t der Publisher muss
nichts {\"{u}}ber die Suscriber (zum Beispiel Anzahl, IP Adresse) und andersrum wissen. Es reicht
wenn beide wissen wo sie sich "treffen" k{\"{o}}nnen. Als zweites gibt es eine zeitliche Trennung zwischen
den Kommunikationspartner --- der Publisher kann Nachrichten verschicken ohne sich dar{\"{u}}ber Gedanken
machen zu m{\"{u}}ssen wann diese beim Suscriber ankommen, w{\"{a}}hrend es f{\"{u}}r den Suscriber
uninteressant ist wann die Nachricht versendet wurde. Der letze Vorteil ist die Entkoppelung von
Nachrichten{\"{u}}bertragung und den anderen Aufgaben des Programmes. Die Nachrichten werden Daten
von ihrer Herstellung verschickt, das Sender einer Nachricht ist also (aus Sicht des
Publishers) O(1) in Bezug auf die Anzahl der Suscriber. Auch auf Seiten des Suscribers gibt es eine
Asynchronit{\"{a}}t, die empfangen Daten werden mithilfe eines Callback angenommen und blockieren damit
nicht die Abarbeitung dieser Daten.

\begin{figure}
	\centering
	\includevisio{pubsub}
	\caption{Publish-Suscribe}
	\label{fig:pubsub}
\end{figure}
\todo{sieht kacke aus. kleiner und andere Auflösung?}


\clearpage
\section{Netzwerklibrary}
Um die Kommunikation zwischen den einzelnen Netzwerkteilnehmern nicht komplett selbst zu implementieren, k{\"{o}}nnen bereits bestehende Netzwerklibraries genutzt werden.
Diese bieten, zum Beispiel, die M{\"{o}}glichkeit an einem entfernten Netzwerkteilnehmer Funktionen aufzurufen oder sich f{\"{u}}r Multicasts anzumelden, auch wenn man in einem anderen
\textit{subnet} ist.

\subsection{Anforderungen}
Um verteilte Systeme zu programmieren, bietet sich das RPC Modell an, mit dem auf einem anderen Rechner Funktionen aufrufen kann.

Es gibt allerdings keine Netzwerklibrary, die dieses Pattern und RPC anbietet; da es einfacher ist, auf Publish-Suscribe ein RPC Modell aufzubauen, als dieses Pattern, zum Beispiel, grpc beizubringen, wird
diese Funktionalit{\"{a}}t vorgezogen.

Netzwerkbibliotheken, die in C++ geschrieben wurden, k{\"{o}}nnen zwar (mit einem Interface) auch unter C benutzt werden, f{\"{u}}gen dem Programm
dann aber "heimlich" die C++ Runtime hinzu. Eine rein in C geschriebene Bibliothek ist daher vorzuziehen.

\clearpage % make sure the table is, at least, in the right section
\begin{table}[h]
\centering
\begin{tabu}{c | c | c | c | p{5cm}}
	\toprule
	Name & RPC & Publish-Suscribe & C++ Runtimeabh{\"{a}}ngigkeit & andere Sprachen \\
	\midrule
	SunRPC & \checkmark & \xmark & \checkmark & C\#, Java, ... \\
	grpc\cite{grpc} & \checkmark & \xmark & \xmark & C\#, Python, Java, ... \\
	ZeroMQ\cite{zeromq} & \xmark & \checkmark & \xmark & C\#, Python, Java, ... \enquote{40+ languages} \\
	nanomsg\cite{nanomsg} & \xmark & \checkmark & \checkmark & C\#, Python, Java, ... (25 Sprachen) \\
	\bottomrule
\end{tabu}
\caption{Anforderungen an die Netwerkbibliothek}
\end{table}

Aus dieser vergleichenden Darstellung wird klar, dass nanomsg am besten geeignet ist; auf dessen speziellen Eigenschaften wird nun n{\"{a}}her eingegangen.

\subsection{nanomsg}
nanomsg ist eine komplett in C geschrieben Netzwerkbibliothek, mit einer API die der POSIX Socket API gleicht (es wird sich also, zum Beispiel mit nn\_connect() verbunden oder mit nn\_send() gesendet).
Der gro{\ss}e Vorteil von nanomsg sind die implementierten {\"{U}}bertragungsarten. Je nach gew{\"{u}}nschter {\"{U}}bertragungsart wird ein unterschiedlicher Socket erstellt, dieser erlaubt die
Interaktion mit den anderen Netzwerkteilnehmern die auch diese {\"{U}}bertragunsart benutzen.

Beispielhaft wird nun auf einige der genutzten Arten eingegangen.

\paragraph{{\"{U}}bertragungsarten}
\subparagraph{Request-Reply} Die intuitiv verst{\"{a}}ndlichste Art zu kommunizieren ist es eine Frage zu stellen, die dann vom Gegen{\"{u}}ber beantwortet wird. In nanomsg ist dies die request-reply
{\"{U}}bertragungsart.

\clearpage
\section{Serialisierung}
Durch die Benutzung der Unity 3D Engine ist die Benutzung von C\# vorgeschrieben, der Rest der Arbeit soll in C geschreiben werden. Die Verwendung verschiedener Sprachen erschwert die Benutzung eines
Bin{\"{a}}rprotokoll --- aus diesem Grund werden die Daten serialisiert.

\subsection{Anforderungen}
Das wichtigste Auswahlkriterium der Serialsierungslibrary ist, dass es eine C (f{\"{u}}r das Studenteninterface) und eine C\# Version (f{\"{u}}r Unity) gibt.
Desweiteren sollen die serialisierten Nachrichten m{\"{o}}glichst klein sein, um auch nach der Anwendung
eines fehlerkorrigierenden Codes so wenig Redudanz wie m{\"{o}}glich aufzuweisen und damit nur wenig f{\"{u}}r Paketverf{\"{a}}lschungen anf{\"{a}}llig zu sein.

\begin{table}[h]
\centering
\begin{tabu}{c | c | c | c | p{5cm}}
	\toprule
	Name & Wenig Redudanz? & C Version & C\# Version \\
	\midrule
	JSON & \xmark & \checkmark & \checkmark \\
	XML & \xmark & \checkmark & \checkmark \\
	ProtoBuf & \checkmark & \xmark\footnotemark & \checkmark \\
	Msgpack\cite{msgpack} & \checkmark & \checkmark & \checkmark \\
	BSON & \checkmark & \checkmark & \checkmark \\
	\bottomrule
\end{tabu}
\caption{Anforderungen an die Serialisierungsbibliothek}
\end{table}
\footnotetext{Es existieren unoffizielle, nicht mehr weiterentwickelte Implementation} 

Bekannte Serialisierungsformate wie JSON und XML enthalten zu viel Redudanzen und k{\"{o}}nnen ausgeschlossen werden. Zur Auswahl bleiben damit beispielsweise BSON und MsgPack.
Bei BSON werden die Daten an sich effizient serialisiert, allerdings wird immer der Feldname mitgesendet. Dies erleichtert zwar die Versionierbarkeit, vergr{\"{o}}{\ss}ert
die Nachricht allerdings. Aus diesem Grund wird MsgPack als Serialisierungsformat genutzt.

\subsection{MessagePack}
MessagePack ist ein in {\"{u}}ber 50 Sprachen verf{\"{u}}gbares Serialisierungsframework, dessen Nachrichten besonders wenig Redudanzen enthalten sollen. Beispielhaft wird hier auf die Serialisierung von
Integern und Zeichenketten mit fester L{\"{a}}nge eingegangen.

Die Grundpidee von MessagePack ist es Datentypen nicht mit fester Breite sondern nur mit der minmal n{\"{o}}tigen Breite (oder wenigstens einer Ann{\"{a}}hrung an diese) abzuspeichern.
\paragraph{Integer} Da Datens{\"{a}}tze oftmals aus vielen kleinen Integerwerte bestehen, macht es Sinn gerade die Serialsierung dieser zu optimieren. Im Gegensatz zur "normalen" Verarbeitung als immer gleich breite (zum Beispiel 64bit) Zahlen, werden vorzeichenlose Integerwerte kleiner als 128 in einem Byte abgespeichert; der Wert des Bytes entspricht dabei dem Wert des Integers. Dahingegen signalisiert ein gesetztes MSB das es kein (kleiner) Integerwert sondern ein anderer Datentyp ist.
\paragraph{Fixed Size String} Um kleinere Zeichenketten zu encodieren gibt es erst ein Signalzeichen \todo{besseres wort} in dem die obersten 3 bits gesetzt sind. Die restlichen 5bits geben die L{\"{a}}nge der Zeichenkette an --- also maximal $2^5 - 1 = 31$ Zeichen. Dies f{\"{u}}hrt zu einem durchschnittlichen Overhead von $ \frac{1}{\frac{2^5-1}{2}} \approx 6\% $.

L{\"{a}}ngere Zeichenketten werden mit anderen Signalzeichen kodiert, beispielsweise 0xDB f{\"{u}}r eine Zeichenketten mit der Maximall{\"{a}}nge von $(2^{32})-1$ Zeichen.
In diesem Fall folgt die L{\"{a}}ng als 32bit big endian
\footnote{L{\"{a}}ngen werden immer in big-endian kodiert um den Datenaustausch auch zwischen Rechnern unterschiedlicher Architekturen gew{\"{a}}rleisten zu k{\"{o}}nen.}
Wert mit fester Breite. Also ein verschwindend geringer durchschnittlicher Overhead von $ \frac{1}{\frac{2^{32}-1}{2}} = 0.00000004\% $.

\clearpage
\section{Quaternions? Vektorrechnung?}

\clearpage
\section{Bewegungen}
Die simulierten Roboter sind an den Kepheraroboter angelehnt, einen gerade im unitversit{\"{a}}ren Bereich weit verbreiteten Roboter mit 2 Motoren und 2 starren R{\"{a}}dern.
Dies gibt auch das Bewegungsmodell vor: \hyperref[diffs]{\textit{differential steering}}, auch \textit{differential drive} genannt. Ausf{\"{u}}hrlicher wird dies im zugeh{\"{o}}rigen Unterkapitel erkl{\"{a}}rt.

\subsection{Khepera}\label{khepera}
\todo{wie gebe ich Quellen fuer einen ganzen Absatz / Sektion an?}
Die Khepera-Roboterserie existiert seit Mitte der 90er Jahre, das neuste Modell ist der Khepera IV\cite{Soares2016}. Dieser Roboter hat eine zylindrische Grundform mit einem Durchmesser von 140mm und einer
H{\"{o}}he von 58mm. Der Roboter wiegt 540g und kann zus{\"{a}}tzlich bis zu 2kg Nutzlast tragen.

Auf der Unterseite sind 2 starre R{\"{a}}der, angetrieben von jeweils einem elektrischen Servomotor. Damit erreicht der Roboter Geschwindigkeiten von bis zu einem Meter pro Sekunde.
Um die Position des Roboters odeometrisch bestimmen zu k{\"{o}}nnen, geben die Motoren auch aus, wie oft sich das jeweilige Rad schon gedreht hat. Zus{\"{a}}tzlich dazu hat der Roboter
auch Infrarot-, Ultraschall- und Lichtsensoren, mit denen die Umgebung wahrgenommen werden kann. Dies kann z.B. genutzt werden um Kollisionen zu vermeiden.
Mithilfe der integrieten Beschleunigungs- und Gyrosensoren kann der Roboter auch seine Geschwindigkeit und seine Neigungswinkel feststellen.

Gesteuert wird der Khepera IV von einer ARM CPU, auf der ein vollwertiges Linux l{\"{a}}uft. Des weiteren gibt es auch ein WLAN Modul, eine Kamera und Lautsprecher plus Mikrophon.

\begin{figure}
	\centering
	\includevisio{k4-detail1.png}
	\caption{Der Khepera IV Roboter}
	\label{fig:kheperaiv}
\end{figure}
\clearpage

\subsection{Differential Steering}\label{diffs}
Beim \textit{differential steering} k{\"{o}}nnen die R{\"{a}}der nicht, wie z.B. beim Auto, geschwenkt werden -- sie sind fest. Es kann zwischen drei Bewegungsarten unterschieden werden:
\begin{itemize}
\item Falls die R{\"{a}}der gleich schnell drehen, f{\"{a}}hrt der Roboter gerade nach vorne oder hinten.
\item Falls die R{\"{a}}der unterschiedlich schnell, aber in die gleiche Richtung rotieren, wird eine Kurve gefahren. Dabei dreht sich der Roboter in Richtung des langsamer rotierenden Rades.
\item Falls die R{\"{a}}der in unterschiedliche Richtungen rotieren, wendet der Roboter auf der Stelle. Dabei dreht sich der Roboter auch wieder in Richtung des langsamer rotierenden Rades.
\end{itemize}

Diese Bewegungen k{\"{o}}nnen auch mathematisch ausgedr{\"{u}}ckt werden. Dabei gibt $V_r(t)$ die Rotationsgeschwindigkeit des rechten Motors zum Zeitpunkt t an, w{\"{a}}hrend $V_l(t)$ den
linken Motor beschreibt. \gls{R} ist der Radius eines Rades, und \gls{L} die Distanz zwischen den R{\"{a}}dern.
Folgende Gleichungen aus \cite{Dudek2010, Egerstedt}:
\begin{subequations}\label{eq:diffs}
\begin{align}
	\Theta(t) &= \Theta(0) + \frac{R}{L} \int_0^t \mathrm{v_R(t) - v_L(t)}\mathrm{d}t \label{eq:diffs-theta}\\
\intertext{Mithilfe der Orientierung zum Zeitpunkt $t$ ist es m{\"{o}}glich die "Fahrtrichtung" zum
	Zeitpunkt $t$ zu bestimmen. Eine Multiplikation dieser mit den Geschwindigkeitsvektoren ergibt den
	Bewegungsvektor zum Zeitpunkt $t$ - daraus l{\"{a}}sst sich die Position ermitteln:
}
	x(t) &= x(0) + \frac{1}{2} \int_0^t \mathrm{\big(v_R(t) + v_L(t)\big) * \cos\big(\Theta(t)\big)}\mathrm{d}t \label{eq:diffs-x}\\
	y(t) &= y(0) + \frac{1}{2} \int_0^t \mathrm{\big(v_R(t) - v_L(t)\big) * \cos\big(\Theta(t)\big)}\mathrm{d}t \label{eq:diffs-y}
\end{align}
\end{subequations}

\subsection{Wegfindung}
\todo{nur allgemein irgendwie kurve fahren vs. erst drehen dann gerade fahren}

\clearpage
\section{Die Gleichgewichte?}
Die Platte soll sich im Gleichgewicht befinden, also sich nicht bewegen und nicht gekippt sein. Dies ist nur der Fall, wenn alle Kr{\"{a}}fte/Gewichte (der Objekte, also der F{\"{u}}llstation und aller Roboter) die auf die Platte wirken, sich zu Null aufaddieren. Dabei werden die Objekte als Vektoren bestehend aus Gewicht und Abstand zum Mittelpunkt betrachtet.

Um das Kippen der Platte auf der links-rechts und vorne-hinten Achse getrennt angeben zu k{\"{o}}nnen, werden diese getrennt voneinander ausgerechnet. Dabei wird das Hebelgesetz im eindimensionalen Fall (wie auf einer Wippe) angewandt, also Distanz mal Masse ergibt die Kraft in dieser Richtung\footnote{Da die Positionsbestandteile (x und y) einzeln betrachtet werden, muss der Winkel nicht in die Rechnung einflie{\ss}en}.

F{\"{u}}r die in Links-Rechts wirkende Kr{\"{a}}fte gilt Gleichung ~\ref{eq:forces:x}, f{\"{u}}r die Kr{\"{a}}fte die beschreiben wie die Platte nach vorne-hinten gekippt gilt Gleichung ~\ref{eq:forces:y}.
\begin{subequations}\label{eq:forces}
\begin{align}
	V(x) = x(F) * w(F) + \sum_{i=0}^{|\gls{N}|} ( x(N_i) * w(N_i) ) \label{eq:forces:x}\\
	V(y) = y(F) * w(F) + \sum_{i=0}^{|N|} ( y(N_i) * w(N_i) ) \label{eq:forces:y}
\end{align}
\end{subequations}

Das Ziel ist es die Platte auszubalancieren, also soll gelten:
\begin{equation}\label{eq:gleichgewicht}
	V(x) = V(y) = 0
\end{equation}

\todo{bild, wie im code die dolle ascii art}
Um aus den Kr{\"{a}}ften den Kippwinkel zu errechnen muss, wie im Bild dargestellt, der Arcussinus genutzt werden. Dabei ist die "Hypotenuse" das Plattengewicht ($ N_Platte = 1000$). \todo{das wirkt total komisch. Ich teile Kraft/Gewicht? Und sowieso kann man asinus fuer solche Sachen ueberhaupt benutzen?}
$$ asin(\frac{V(x)}{ N_Platte}) = \beta = W_{x}, asin(\frac{V(y)}{N_Platte}) = \alpha = W_{y} $$


