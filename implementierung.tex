\clearpage
\section{Architektur}

\subsection{XX}
event gesteuerte kommunikation.
\todo{mhm, irgendwie ne begruendung}
anforderung 2, mehrere instanzen

\subsection{Anzeige}\label{graphics}
F{\"{u}}r interessierte Sch{\"{u}}ler und auch f{\"{u}}r die Studenten die diese Aufgabe l{\"{o}}sen
sollen muss es m{\"{o}}glich sein einzusch{\"{a}}tzen wie der momentane Status der Simulation ist.
Also wo befinden sich Roboter, wie voll sind sie, wie stark kippt die Platte? All dies soll auch, wie
in \hyperref[anforderung]{Anforderung 5} festgelegt, visuell ansprechend sein.

Da die Unity Engine auch eine vollwertige Grafikengine ist (dies war ja schliesslich ein Kriterium)
kann diese Funktionalit{\"{a}}t genutzt werden. Das Simulationsprogramm ist nicht nur f{\"{u}}r die
reine Simulation sondern auch f{\"{u}}r die Anzeige verantwortlich.

Angezeigt wird eine kreisf{\"{o}}rmige Platte auf der sich die verschiedenen Roboter bewegen. Auch die
Ladestation wird angezeigt.

\paragraph{Kamera} Die Sicht auf die simulierte Welt geschieht durch das Unity Objekt "Camera". An diese werden verschiedene Skripte angegeh{\"{a}}ngt um z.B. dem Benutzer die M{\"{o}}glichkeit zu
geben die Kamera zu bewegen oder \todo{halt noch irgendwas}.

Die Kamera kann {\"{u}}ber die Pfeiltasten bewegt werden, ein Kippen der Kamera ist nicht implementiert - dies w{\"{u}}rde auch verwirren, da damit eventuell der Kippwinkel der
Platte visuell ausgeglichen werden k{\"{o}}nnte.

\paragraph{Lichtquelle} Um die Szene auszuleuchten, gibt es ein Spotlight. Dies befindet sich an der Stelle \todo{nachgucken} und scheint mit einem XXXX\textdegree Winkel nach unten.

\clearpage
\section{Fehlermodell}\label{fm}
Das Ziel der Aufgabe ist es Studierenden etwas {\"{u}}ber ausfallsichere Systeme beizubringen. Daf{\"{u}}r
muss auch etwas ausfallen, damit dann die Auswirkungen des Ausfalls abgemindert werden k{\"{o}}nnen.

Im Fehlermodell wird festgelegt was alles -- und auf welche Weise -- ausfallen kann. Dabei wird f{\"{u}}r jeden Bestandteil der Simulation ein eigenes Fehlermodell aufgestellt. Die Bestandteile
der Simulation sind hier die simulierte Welt mit ihren Robotern (und den dazugeh{\"{o}}rigen Motoren/Aktoren
und Sensoren), die Kommunikationswege zwischen Voter und Controller und die Controller selbst.

\subsection{Roboter / Motoren}
Die simulierten Roboter {\"{a}}hneln dem Khepera Roboter und haben daher 2 Motoren. Diese beiden Motoren k{\"{o}}nnen unabh{\"{a}}ngig von einander fehlerhaft sein. Fehlerhaft
hei{\ss}t hier:
\begin{itemize}
	\item Die H{\"{a}}ufigkeit von Hardwarefehler wird oft mithilfe der Badewannenkurve modelliert. Sie besagt das Hardware entweder kurz nach Inbetriebnahme oder nach
		langer Betriebszeit mit hoher Wahrscheinlichkeit fehlerhaft ist, und in der Zwischenzeit nur mit niedriger Wahrscheinlichkeit. F{\"{u}}r die Motoren der Roboter wird
		ein vereinfachtes Modell genutzt, in dem die Wahrscheinlichkeit f{\"{u}}r einen Ausfall bis zu einer bestimmten Betriebslaufzeit einstellbar ist und danach auf
		Null sinkt. Falls der Motor in dieser Zeit Fehler aufweist, bleibt diese Fehler auch.
	\item Desweiteren kann ein Motor tempor{\"{a}}r ein Stuck-At Verhalten aufweisen. Dieses kann jederzeit passieren und entweder tempor{\"{a}}rer oder permament sein.
		Die Wahrscheinlichkeiten f{\"{u}}r das Auftreten eines permamenten oder tempor{\"{a}}ren Stuck-At Fehlers sind unabh{\"{a}}ngig voneinander einstellbar.
\end{itemize}

Da jeder der \gls{N} Roboter 2 Motoren hat, k{\"{o}}nnten theoretisch auch 2 Motoren kaputt gehen. Ein Roboter mit einem fehlerhaften Motor kann allerdings immernoch sinnvoll genutzt werden,
bei einem Roboter mit 2 fehlerhaften Motoren ist dies nicht der Fall. Es soll m{\"{o}}glich sein verschiedene 
Schwierigkeitsstufen der Simulation einzustellen. Daher ist es m{\"{o}}glich
dass nur ein Motor pro Roboter gleichzeitig Fehler aufweisen kann.

Aus dem gleichen Grund ist es parametresierbar wie viele Roboter gleichzeitig irgendeine Art von Fehler aufweisen k{\"{o}}nnen.

Zus{\"{a}}tzlich zu diesen Fehler soll es auch m{\"{o}}glich sein einen Roboter fernzusteuern. W{\"{a}}hrend
der Fernsteuerung darf dieser Roboter keine Steuerbefehle seines Voters ausf{\"{u}}hrend sonder wird rein
vom Nuter gesteuert. Diese Art der Fehlerinjektion w{\"{u}}rde in Richtung byzantinische Fehler gehen,
denn dies w{\"{u}}rde es erm{\"{o}}glichen gezielt die Platte zu destabilisieren oder Roboter zu
blockieren.

\subsection{Weltstatusinformationen}
Die Roboter haben ihre Aktoren, um sich in der Welt zu bewegen. Damit sie sich sinnvoll bewegen und die Platte balanciert k{\"{o}}nnen, brauchen sie Informationen {\"{u}}ber den
Status der Welt und ihre (und die der anderen Roboter) Position in dieser. Diese Informationen sind direkt verf{\"{u}}gbar und m{\"{u}}ssen nicht, zum Beispiel odeometrisch,
erst herausgefunden werden. In der realen Welt sind Sensoren, wie sie hier vielleicht h{\"{a}}tten simuliert werden k{\"{o}}nnen, nat{\"{u}}rlich manchmal fehlerbehaftet.
Um dies nachzubilden k{\"{o}}nnen die Informationen {\"{u}}ber den Weltstatus auf verschiedene Arten fehlerhaft an den Roboter weitergeleitet werden.

Als erstes ist es m{\"{o}}glich das der Roboter einfach keinerlei Informationen mehr bekommt, also ein \textit{omission failure} vorliegt. Ein \textit{stuck-at} Fehler liegt
vor wenn veralterte Informationen wieder an den Roboter weitergegeben werden, so als w{\"{u}}rde ein Sensor nur noch seine letzen g{\"{u}}ltigen Daten liefern. Der dritte
Fall liegt vor, wenn komplett falsche Daten geliefert werden. Komplett falsch hei{\ss}t, dass die Anzahl und die Positionen, Gewichte etc. der Roboter potenziell fehlerhaft an
den Roboter weitergegeben werden. Die Wahrscheinlichkeiten f{\"{u}}r die jeweiligen F{\"{a}}lle lassen sich unabh{\"{a}}ngig von einander einstellen.

\subsection{Netwerk}
Da die simulierten Roboter den Khepera Robotern {\"{a}}hneln sollen, sollen auch ihre Kommunikationsm{\"{o}}glichkeiten denen der Khepera Roboter {\"{a}}hneln. Bei
beweglichen Objekten sind Ethernetkabel suboptimal, weswegen diese Funkverbindungen bevorzugen. Funkverbindungen haben aber, im Gegensatz zu gut abgeschirmten
Ethernetkabeln, Probleme mit Interferenzen durch andere Funk{\"{u}}bertragungen.

Dies f{\"{u}}hrt dazu das w{\"{a}}hrend der {\"{U}}bertragung Bits, oder sogar ganze Bytes, verf{\"{a}}lscht werden. Auch die Wahrscheinlichkeit f{\"{u}}r diesen Fall
soll einstellbar sein. Vereinfachend wird hier angenommen das jeweils nur ein Byte pro Paket verf{\"{a}}lscht wird, es gibt also keine \textit{burst errors}.
Es wird angenommen das die meiste Kommunikation zwischen Robotern "in Sichtweite" geschieht, ohne Zwischenstationen und komplexes Routing. In diesem Fall ist
es ist un{\"{u}}blich das Pakete verloren gehen oder zeitverz{\"{o}}gert weitergeleitet werden, daher ist dies nicht Teil des Fehlermodells.

\subsection{Controller}
Es wird davon ausgegangen das die Controllerprogramme auf unzuverl{\"{a}}ssiger Hardware, unzuverl{\"{a}}ssigen Betriebssystem laufen und fehlerhaft programmiert sind.
Daher muss davon ausgegangen werden das die Programme jederzeit abst{\"{u}}rzen k{\"{o}}nnen. Desweiteren kann auch nicht davon ausgegangen werden das die
Controllerprogramme das einzige Programm ist das l{\"{a}}uft; es kann also auch zu Problemen bei der Resourceverteilung (RAM, CPU Zeit) kommen.

\subsection{Auswirkungen}
\todo{irgendwie passt das nicht so wirklich hier hinter...}
Nachdem Fehlermodelle f{\"{u}}r die verschiedenen Elemente des Systems entwickelt wurden, kann betrachtet werden welche Auswirkungen die verschiedenen Fehler haben
k{\"{o}}nnen.

\paragraph{Unkontrollierte Bewegung} Falls sich ein Roboter unkontrolliert bewegt (also ein oder mehrere Motoren einen Stuck-At Fehler und die
verbliebenden Motoren gar nicht mehr funktionieren) kann dieser Roboter nicht mehr genutzt werden um die Platte auszubalancieren.
\begin{figure}
	\centering
	\includevisio[width=\textwidth]{fm_robot}
	\caption{Fehlerbaum: Unkontrollierte Bewegung eines Roboters}
	\label{fig:fault-tree-robot}
\end{figure}
\clearpage

\paragraph{Inkorrekte Bewegungen} Ein Roboter bewegt sich "falsch", wenn seine Bewegung weder die Platte ausbalanciert noch dazu gedacht, ist den Energiespeicher
aufzuf{\"{u}}llen. Dies kann verschiedene Gr{\"{u}}nde haben: Entweder bewegt der Roboter sich unkontrolliert oder er wird falsch angesteuert. Dies kann passieren
falls, die Controller falsche Steuerkommandos senden, oder theoretisch richtige Steuerkommandos falsch ausgewertet werden.
\begin{figure}
	\centering
	\includevisio[width=\textwidth]{fm_robot2}
	\caption{Fehlerbaum: Inkorrekte Bewegung eines Roboter}
	\label{fig:fault-tree-robot2}
\end{figure}
\clearpage

\clearpage
\section{Fehlerinjektion}
Da es in der Simulation, anders in einer realen Welt, keine normalen Fehlerquellen gibt, wird eine
Fehlerinjektion benutzt, um die Fehlertoleranz zu testen. Die hier simulierten Fehlerarten 
sind im \hyperref[fm]{Fehlermodell} beschrieben.

In diesem Fall wird simuliert, dass das Netzwerk Daten fehlerhaft weiterleitet (wie es z.B. ein Funknetzwerk tuen w{\"{u}}rde) und das die Controllerprogramme
unvorhersehbar ausfallen - was nachbildet, dass z.B. der Controller seine Batterie entladen hat.

Wie in \hyperref{anforderung}[Anforderung 3] spezifiert, sind alle Fehlerwahrscheinlichkeiten einstellbar.

\subsection{Netzwerk}
Die Kommunikation zwischen Voter und Controller ist nur {\"{u}}ber ein IP Netzwerk m{\"{o}}glich; f{\"{u}}r dieses Modul kann ein eigenes Netzwerk aufgebaut werden, in das eine
Fehlerinjektionskomponente intergiert werden kann. Diese Komponente soll nur die Kommunikation, die von den Studentenprogrammen ausgeht, verf{\"{a}}lschen und alle andere normal
behandeln. Die St{\"{a}}rke der Fehlerinjektion soll parametresierbar sein, zum Beispiel wie wahrscheinlich es ist, das, einzelne Pakete verf{\"{a}}lscht werden, oder wie stark
die Verf{\"{a}}lschung sein soll.

Es wird vorgeschrieben, dass die ganze Kommunikation der Studentenprogramme {\"{u}}ber UDP laufen muss. Dadurch reicht es, wenn der Fehlerinjektor nur UDP verf{\"{a}}lscht, was dazu
f{\"{u}}hrt, dass die normalen Administrationstat{\"{a}}tigkeiten nicht beeintr{\"{a}}chtigt werden. Der Fehlerinjektor muss in der Lage sein, mit einstellbaren Wahrscheinlichkeiten
Pakete zu verf{\"{a}}lschen: bei den Arten der Verf{\"{a}}lschung ist es ausreichend, wenn einzelne Bytes gekippt werden.

Daf{\"{u}}r zust{\"{a}}ndig ist Net Inject\cite{kubertzki}. Dabei werden auf den fraglichen Rechnern
Standartrouten definiert, die den Netzwerkverkehr {\"{u}}ber andere Rechner leiten, auf denen Net Inject
installiert ist. Dort werden die Pakete vom Modul NetMod angenommen und es wird {\"{u}}berpr{\"{u}}ft ob
f{\"{u}}r diese Kommunikation (spezifiziert durch Protkoll, Quell- und Zielport) Verf{\"{a}}lschungsregeln
existieren. Anhand dieser Regeln wird das Paket dann ausgwertet und, bei Bedarf, verf{\"{a}}lscht.

Standardm{\"{a}}ssig ist dieser Fehlerinjektor so eingestellt dass durchschnittlich in $ ^1/_{20} $ aller Pakete ein Byte verf{\"{a}}lscht wird,
ohne dass das Betriebssystem diese Modifikation erkennt. Diese Erkennung muss also von den Studenten selbst implementiert werden.

\subsection{Controller}
Im Fehlermodell wurde spezifiziert das die Controller zu beliebigen Zeitpunkten einen \textit{crash failure} erleiden k{\"{o}}nnen.

Um dies zu erm{\"{o}}glichen gibt es ein Shellskript, das die Controllerprogramme zu zuf{\"{a}}ligen Zeitpunkten beendet und wieder startet - dabei wird das Programm einfach mit SIGKILL beendet und nicht vorgewarnt.
Mit einer Wahrscheinlichkeit von 33\% werden dem Programm auch nur eingeschr{\"{a}}nkte Ressourcen zugeteilt, z.B. darf es nur eine bestimmte Anzahl an Dateideskriptoren gleichzeitig
offen haben oder nur eine eingeschr{\"{a}}nkte Menge Speicher benutzen.
\lstinputlisting{../fault_injector.sh}

\subsection{Simulation}
Auch innerhalb der Simulation soll es Fehler geben, zum Beispiel an den Robotermotoren. Desweiteren soll,
laut Fehlermodell, auch die Fernsteuerung eines Roboters m{\"{o}}glich sein.

\subsubsection{xxx}
Laut \hyperref[fm]{Fehlermodell} k{\"{o}}nnen die Robotermotoren auf verschiedene Arten fehlerbehaftet sein und die Voter bekommen eventuell
fehlerhafte, oder sogar gar keine, Informationen {\"{u}}ber den Status der Welt. Die Wahrscheinlichkeiten f{\"{u}}r diese verschiedenen F{\"{a}}lle
werden in einer JSON Konfigurationsdatei angegeben. Die Simulation liest diese beim Start aus und ver{\"{a}}ndert\todo{doofes wort} dann w{\"{a}}hrend des laufenden Betriebes
die Robotermotoren. Ein Teil der Informationen muss an den Voter weitergegeben werden, daher fragt dieser beim Start automatisch die ben{\"{o}}tigten Daten ab.

Der Status der Welt der von der Simulation zum Voter geschickt wird kann, wie im \hyperref[fm]{Fehlermodell} angegeben, verf{\"{a}}scht werden, kann zeitweise gar
nicht ankommen oder es kann ein alter Status erneut versendet werden. Die Wahrscheinlichkeiten f{\"{u}}r diese drei F{\"{a}}lle werden direkt angegeben.
\begin{lstlisting}[frame=single, language=json] 
{
	"network" : {
		"dropWorldStatus": 0.001,
		"fakeWorldStatus": 0.001,
		"dupWorldStatus": 0.001
	}
}
\end{lstlisting}

Die zweite Kategorie von Fehlern sind die Ausf{\"{a}}le der Motoren. Direkt angegeben werden die maximale Anzahl an fehlerhaften Robotern und die maximale
Anzahl an fehlerhaften Motoren pro Roboter. Die einzelnen Motoren k{\"{o}}nnen entweder tempor{\"{a}}r oder permament fehlerbehaftet (Stuck At oder keinerlei Leitung) sein.
Die Wahrscheinlichkeiten f{\"{u}}r diese beiden Fehlerarten werden getrennt angegeben und k{\"{o}}nnen entweder einer zeitunabh{\"{a}}nigen festen Wahrscheinlichkeit oder
der Badewannenkurve folgen. Bei der Badewannenkurve wird zus{\"{a}}tzlich zur Ausfallwahrscheinlichkeit auch noch die Dauer (in s) des ersten Bereiches angegeben.
\begin{lstlisting}[frame=single, language=json] 
{
	"robot" : {
		"breakEngineA" : {
			"perm": {"after": 120, "chance" : 0.01}
		},
		"stuckAtEngineA" : {
			"temp": 0.00001
		},
		"maxEnginesBroken": 3,
		"maxEnginesBrokenPerRobot": 1
	}
}
\end{lstlisting}

\todo{temporaer sind jetzt nur quasi einen frame lang...}

\subsubsection{Fernsteuerung}
Wie im \hyperref[fm]{Fehlermodell} festgelegt soll der Benutzer einen Roboter fernsteuern k{\"{o}}nnen und damit direkten Einfluss auf die simulierte Welt haben. W{\"{a}}hrend ein Roboter
ferngesteuert wird, f{\"{u}}hrt dieser eine Roboter keine Befehle seines Voters mehr aus. Abgesehen davon verh{\"{a}}hlt sich der Roboter normal, es wird also die gleiche Menge Energie verbraucht,
es gelten die gleichen Einschr{\"{a}}nkungen bei Geschwindigkeit und Rotation, und so weiter.

Dies wird durch ein Script in Unity erm{\"{o}}glicht. Im deaktivierten Zustand zeigt es einen Hilfetext auf dem Bildschirm an. Mit der Escapetaste wird die Fernsteuerung aktiviert, dann kann ein
Roboter {\"{u}}ber die Pfeiltasten gesteuert werden (Vorw{\"{a}}rts beschleunigt, Links und Rechts drehen den Roboter).
Um anzuzeigen, welcher Roboter gerade gesteuert wird wird dieser von oben angeleuchtet. Mit der Tabulatortaste kann zwischen den
Robotern umgeschaltet werden. Bei einem weiteren Druck auf die Escapetaste wird die Fernsteuerung deaktiviert.


\clearpage
\section{Die Welt}
Die simulierte Welt besteht aus den Robotern, die von den Studierenden gesteuert werden sollen, einer Ladestation, an der die Robter Energie tanken k{\"{o}}nnen, und
der Welt, einer kreisf{\"{o}}rmigen, kippbaren Platten, auf der diese Objekte platziert werden und sich bewegen k{\"{o}}nnen.

Simuliert wird die Welt mit der Unity \textit{game engine}. Diese erm{\"{o}}glicht es plattformunabh{\"{a}}nige Spiele oder, in diesem Fall, Simulationen zu schreiben.
Dabei stellt sie, unter anderem eine Physikengine, eine Grafikengine und eine Schnitstelle zum scripten dieser bereit. 

\subsection{Die Roboter}\label{robot}
In der simulierten Welt k{\"{o}}nnen sich bis zu \gls{N} Roboter bewegen. Diese bewegen sich aber nicht selbstst{\"{a}}ndig, sondern werden von den Controllern ferngesteurt.
Wie sie in der Simulation dargestellt werden, wird durch das grafische Modell bestimmt. Anhand dessen bestimmen sich auch die Dimensionen, diese werden f{\"{u}}r die Kollisionerkennung
gebraucht. Die Dimensionen, zusammen mit der Masse, ergeben das physische Modell, dieses hat Auswirkungen auf die Simulation.

\paragraph{Grafisches Modell} Mithilfe von Blender, einem 3D Designprogramm, wurde ein Robotermodell designt, das dem Kepheraroboter\ref{khepera} entspricht. Die Grundform des Roboters ist
eine S{\"{a}}ule.
Der Energielevel wird {\"{u}}ber eine Lampe auf der Oberseite angezeigt, die ihre
Farbe von Gr{\"{u}}n (voll), {\"{u}}ber Gelb bis Rot (leer) {\"{a}}ndert.
\todo{Bild}


\paragraph{Physikalisches Modell}
\todo{muss das nicht auch irgendwie in die Grundlagen? Oder ist das Implementierung}
Ein Roboter \gls{Ni} wird dabei beschrieben durch seine Position und Gewicht
$ N_i = \bigl(\begin{smallmatrix} x(i) \\ y(i) \\ w(i) \end{smallmatrix}\bigr)$, eine
Geschwindigkeit $ V_i = \Delta v $ und den momentanen Drehwinkel
$ R_i = r_y(i)$. \todo{Ausdehnung}

Das Gewicht des Roboters ist abh{\"{a}}ngig vom Grundgewicht des Roboters und seinem momentanen F{\"{u}}llstatus: 
\begin{equation}
    \label{eq:w}
 w(N_i) = 1 + e(N_i) * 0.03
\end{equation}

Die Roboter haben einen Energiespeicher, der mit maximal 1000 Energieeinheiten
aufgeladen werden kann, und verbrauchen diese Energie, ob beim Fahren oder
Stillstand. Dabei verbrauchen sie pro Runde ohne Bewegung immer eine Energieeinheit und zus{\"{a}}tzlich, abh{\"{a}}ngig von der Geschwindigkeit, Energie f{\"{u}}r die Bewegung:
\begin{equation}
    \label{eq:entladen}
	e(N_i, t + 1) = e(N_i, t) - 1 - |V_i|
\end{equation}
Falls nicht gen{\"{u}}gend Energie f{\"{u}}r Bewegung und Rotation vorhanden ist, bewegt sich der Roboter nicht.

Die Bewegung des Roboters wird vorgegeben durch $V_l(t)$ und $ V_r(t)$. Diese werden vom Controller, {\"{u}}ber den Voter an die Simulation weitergegeben und dann von Unity verarbeitet.
Die neue Position und der neue Rotationswinkel des Roboters werden errechnet und, falls gen{\"{u}}gen Energie
vorhanden, auch eingenommen - dazu wird der \textit{rigidbody} des Roboters manipuliert.
Um die Bewegung fl{\"{u}}{\ss}iger darzustellen wird zwischen den momentanen und gew{\"{u}}nschten Positionen / Winkel interpoliert.

\subsection{Die Ladestation}\label{fuelstation}
Innerhalb der Welt muss eine Ladestation platziert werden, um den Roboter die M{\"{o}}glichkeit zu geben sich aufzuladen. Auch diese wird durch ihren Vektor $ F = \bigl(\begin{smallmatrix} x \\ y \\ w \end{smallmatrix}\bigr)$ beschrieben. Eine Ladestation hat dabei ein festes Gewicht: $ w(F) = 5 $.

Diese wird vor Simulationsbeginn platziert und bewegt sich im weiteren Verlauf nicht.
Falls sich ein Roboter an die Ladestation heranbewegt, also gilt: 
\begin{equation}
    \label{eq:dist}
 |\bigl(\begin{smallmatrix} x(i) \\ y(i) \end{smallmatrix}\bigr) - \bigl(\begin{smallmatrix} x(F) \\ y(F) \end{smallmatrix}\bigr)| \leq |\bigl(\begin{smallmatrix} 1 \\ 1 \end{smallmatrix}\bigr)|
\end{equation}
wird dieser Roboter aufgeladen. Die Ladefunktion ~\ref{eq:laden} ist hier eine einfache Gerade:
\begin{equation}
    \label{eq:laden}
	e(N_i, t + 1) = max((e(N_i, t) + 10, 1000) 
\end{equation}

\subsection{Die Platte}\label{plate}
Die simulierte Welt besteht aus einer 100 Einheiten gro{\ss}en kreisf{\"{o}}rmigen Platte, die, basierend auf den Gewichten welche sich auf ihr befinden kippt.
XXXX \todo{} text, iwie auch auf das da oben beziehen



\clearpage
\section{Interface f{\"{u}}r die Studenten}\label{interface}
Damit die Studenten sich auf die Implementierung der Fehlertoleranz konzentrieren k{\"{o}}nnen, gibt es Schnittstellen.
Im ganzen System gibt es zwei Schnittstellen:
\begin{itemize}
\item Die Schnittstelle zwischen Controller und Voter
\item Die Schnittstelle zwischen Voter und Roboter/Simulation
\end{itemize}

\paragraph{Die Schnittstelle zwischen Controller und Voter} Den Studenten wird nicht vorgegeben wie die Kommunikation zwischen den Controllern und Votern aussehen soll - denn gerade hier soll ja die Fehlertoleranz implementiert werden.

\paragraph{Die Schnittstelle zwischen Voter und Roboter} Diese Schnittstelle besteht aus den Funktionen:
\begin{lstlisting}[frame=single, language=c] 
void* connectToWorld();
void detachFromWorld(void* ctx);
int createRobot(void* ctx);
typedef void (*TypeGetWorldStatusCallback)(WorldStatus ws, void* optional);
int startProcessingWorldEvents(void* ctx, TypeGetWorldStatusCallback cb, void* optional);
void moveRobot(void* ctx, int id, float speed, float angle);
\end{lstlisting}

Diese wird den Studierenden als kompilierte Library mit einem detailliert kommentierten Headerfile zur Verf{\"{u}}gung gestellt und kann
dann vom Studentencode einfach aufgerufen werden.


\clearpage
\section{Beispielimplementation}
Um das Prinzip dieser Simulation, ob den Studierenden des Moduls Ausfallsichere Systeme oder Besuchern, zu verdeutlichen, ist ein Teil der Bachelorarbeit die Implementierung einer
Beispielimplementation.

\paragraph{Ablauf} Jede Viertelsekunde sendet die Welt Statusinformationen aus. Diese Informationen werden von den Votern empfangen, k{\"{o}}nnen
aber auf dem {\"{U}}bertragungsweg zum Controller potenziel verf{\"{a}}lscht worden sein. Also wird f{\"{u}}r jedes Objekt der Welt der Konsensalgorithmus ausgef{\"{u}}hrt. Wenn ein Konsens {\"{u}ber den Status der Welt hergestellt wurde, berechnet 
jeder Controller f{\"{u}}r jeden Roboter die n{\"{a}}chste Bewegung. Diese wird dann an den Voter geschickt, der ein einfaches Mehrheitsvotum durchf{\"{u}}hrt und diese Bewegung an die Welt weitergibt.

\subsection{Fehlermodell} \label{error-model}
Bei der Planung eines ausfallsicheren Systems ist es besonders wichtig zu definieren, welche Art von Fehlern
{\"{u}}berhaupt korrigiert / abgefangen werden soll. F{\"{u}}r dieses Projekt werden f{\"{u}}r jede Fehlerklasse
die m{\"{o}}glichen Fehler aufgelistet und beschrieben, ob und wie sie gel{\"{o}}st werden.

\paragraph{Crash failure} Die Controller k{\"{o}}nnen jederzeit ausfallen. Im Extremfall k{\"{o}}nen alle Controller ausfallen, die Voter sind, per Definition, gegen diese Art von Fehlern unempfindlich.

\paragraph{Value error} Das Netzwerk kann Pakete verf{\"{a}}lschen, es wird angenommen, dass bei bis zu $^1/_{20}$ aller Pakete Verf{\"{a}}lschungen geben kann, diese sich allerdings auf \textit{Single Byte Errors} beschr{\"{a}}nkt.
Dar{\"{u}}ber hinausgehende Verf{\"{a}}lschungen werden nicht erkannt und f{\"{u}}hren zu einem \textit{silent failure}; \todo{auswirkungen}

\subsubsection{R{\"{a}}umliche Redudanz}
Es wird davon ausgegangen, dass die Controller sehr fehleranf{\"{a}}lig sind und leicht ausfallen - daraus folgt das eine gro{\ss}e
Anzahl an Controllern f{\"{u}}r jeden Roboter kontrollieren muss; nur falls weniger als $X$ Controller dieses Roboter noch aktiv
sind kann eine ordnungsgem{\"{a}}{\ss}e Steuerung nicht mehr garantiert werden.

Wenn ein Roboter erstellt wird, werden auch $Y$ Controller gestartet. Die Ausf{\"{u}}hrung der Controller wird durch ein Skript
{\"{u}}berwacht das ausgefallene Controller neu startet. \todo{ist das sinnvoll? dann muss man ja auch das skript killen um dann
irgendwann mal zu wenig controller zu haben}

\subsubsection{Netzwerkkommunikation}
Da durch die Fehlerinjektion das Netzwerk UDP Pakete verf{\"{a}}lscht m{\"{u}}ssen alle Daten mit einer Kanalkodierung versehen werden. Hier wird ein (255, 240) Reed-Solomon Code benutzt, also ein Code, der 15 parity bits pro 240 Datenbits benutzt.
Durch die Benutzung dieser Kodierung k{\"{o}}nnen alle Einzelfehler und Doppelfehler erkannt und korrigiert werden. Erst ab 7 Fehlern ist eine Korrektur nicht mehr m{\"{o}}glich, ab 15 Fehlern versagt auch eine Fehlererkennung.
Diese Kodierungsart wurde aus zwei Gr{\"{u}}nden gew{\"{a}}hlt:
\begin{itemize}
\item Durch expermientelle Verifikation wurde klar, dass im Netzwerk nur 1 Byte pro Paket verf{\"{a}}lscht wird. Da das durchschnittliche Paket um mindestens Faktor
	100 gr{\"{o}}{\ss}er ist, ist nicht erforderlich, eine sehr kompakte Kodierung zu benutzen, es ist ausreichend, die Redudanz zu reduzieren. 
\item Es ist ein systematischer Code, der es erlaubt, w{\"{a}}hrend des laufenden Betriebes die Pakete mitzuschneiden
	und sich die Daten anzugucken. Dies vereinfacht die Fehlersuche - beispielsweise bei einem Viterbicode w{\"{a}}re dies nicht m{\"{o}}glich, dort
	sind Nutz- und Kodierungsdaten nicht klar unterscheidbar.
\end{itemize}

\subsection{Voter}
\label{voter}
Der Roboter kann nur direkt durch den Voter gesteuert werden. Der Voter ist dabei nur daf{\"{u}}r zust{\"{a}}ndig aus den vielen Steuerkommandos die ankommen die Mehrheit zu bilden (\textit{N-modular reduancy}).
Da nicht klar ist wie viele Controller momentan {\"{u}}berhaupt Steuerkommandos senden k{\"{o}}nnten, kann nicht gewartet werden bis eine bestimmte Anzahl von Kommandos empfangen wurde. Deswegen wird beim empfangen
eines neuen Weltstatus das Steuerergebniss gebildet, weggesendet und der Vorgang wird neu gestartet.

Um das Steuerergebniss zu finden werden die empfangenen Steuerkommandos sortiert und der Medianwert genommen (\textit{Mid-Value Selection}). Da die Steuerkommandos
Flie{\ss}kommazahlen enthalten ist keine exakte Votierung m{\"{o}}glich. Die Wahl des Medians f{\"{u}}hrt zus{\"{a}}tzlich dazu das weniger "extreme" Bewegungen bevorzugt werden.
\noindent\begin{minipage}{.30\textwidth}
\begin{lstlisting}[caption=Sammeln, frame=tlrb, language=c++]
votes.res[id].push_back(Vector{x, y});
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.60\textwidth}
\begin{lstlisting}[caption=Auswahl, frame=tlrb, language=c++]
/* go through all robots */
for(auto&& votes : votes.res) {
  /* vote */
  std::sort(std::begin(votes.second), std::end(votes.second));
  auto x = votes.second[votes.second.size() / 2];

  /* send */
  int r = 0;
  if((r = moveRobot(info->worldCtx, votes.first, x.x_, x.y_)) < 0) {
  	fprintf(stderr, "can't move robot: %d", r);
  }
}
\end{lstlisting}
\end{minipage}


\begin{figure}
	\centering
	\includevisio[width=\textwidth]{seqvoter}
	\caption{Ablaufdiagramm Voter}
	\label{fig:sequence-voter}
\end{figure}
\clearpage % make sure the table is, at least, in the right section

\subsection{Controller}\label{controller}
Die Roboter m{\"{u}}ssen sich so bewegen, dass die Platte m{\"{o}}glichst gut ausbalanciert
ist und gleichzeitig die Roboter nicht ihre ganze Tankf{\"{u}}llung verbrauchen. Gleichzeitig sollten die Roboter auch nicht miteinander
kollidieren.

\paragraph{Algorithmus zur Bestimmung der Bewegung} Der implementierte Algorithmus unterschiedet zwischen 3 Situation: ist der Zustand des Roboters kritisch,
unkritisch oder dazwischen? Dabei ist das Kriterium die momentane Tankf{\"{u}}llung geteilt durch die Entfernung zur Ladestation. Roboter mit fast leerem Tank
versuchen also sich aufzuf{\"{u}}llen, Roboter mit fast vollem Tank versuchen auszubalancieren.

Jeder Controller berechnet f{\"{u}}r jeden Roboter wie dieser sich bewegen soll. Dabei wird mit dem Roboter im kritischtesten Zustand anfangen, denn dieser muss ja 
unbedingt Richtung Ladestation und die weniger kritischen k{\"{o}}nnen/m{\"{u}}ssen dann ausgleichen. Nachdem eine Roboterbewegung berechnet wurde, werden die Weltkippwinkel
dementsprechend neu berechnet - so dass die letzten Roboter die Bewegungen der vorher berechneten mit in ihre Entscheidung einbeziehen.

\paragraph{Bewegung} Um zu einem bestimmten Punkt hinzufahren (z.B. zur Ladestation) wird zu erst die Rotation des Roboters in einen Bewegungsvektor umgerechnet. Die Rotation
wird immer in Bezug auf eine feste Richtung angegeben, also kann der Bewegungsvektor durch trigeometrische Funktionen bestimmt werden:
$$ M_i = \bigl(\begin{smallmatrix} sin(R_i) \\ cos(R_i) \end{smallmatrix}\bigr)$$
Desweiteren gibt es einen Distanzvektor zum Ziel:
$$ D_i = \gls{F} - P_i $$

Der Winkel zwischen diesen beiden Vektoren gibt an, wie weit der Roboter sich drehen muss um gerade zu dem Ziel fahren zu k{\"{o}}nnen. Dabei muss beachtet werden, dass nur der Wert des
Winkels berechnet wird, das Vorzeichen allerdings nicht. Der Roboter w{\"{u}}rde also immer nach rechts drehen, damit den Winkel vergr{\"{o}}{\ss}ern und noch st{\"{a}}rker in die
falsche Richtung drehen. Das Vorzeichen kann allerdings berechnet werden, in dem man die Bewegungsvektoren in drei Dimensionen betrachtet und das Keuzprodukt bildet. In dem resultierenden
Vektor gibt das Vorzeichen der Z Kompenente das Vorzeichen des Winkels an.

\paragraph{Ausbalancieren} Um auszubalancieren wird\todo{} 


\clearpage
\section{Evaluation}
nochmal die anforderungen durchgehen
eigentliches ziel ist lehrmittel, weil studenten erst demnaechst anfangen selbst implementieren


