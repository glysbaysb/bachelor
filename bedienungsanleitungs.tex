\documentclass[
    12pt,
    bibliography=totoc,
    ngerman,
    enabledeprecatedfontcommands
]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[ngerman]{babel}
\usepackage{graphicx}
\usepackage{todonotes}
\PassOptionsToPackage{hyphens}{url}
\usepackage[linktoc=all,pdfusetitle]{hyperref}
\newcommand{\includevisio}[2][]{\includegraphics[#1]{#2}}
\graphicspath{{../images/}}
\usepackage{listings}

\begin{document}
%\maketitle 
%\thispagestyle{empty}
%\clearpage

\thispagestyle{empty}
\begin{center}
	\includevisio{fhlogo}\\
	\large
	\textbf{Fachbereich f{\"{u}r}}
	\textbf{Elektrotechnik und Informationstechnik}\\
	\large
	\textbf{Studiengang Technische Informatik}\\
	\vspace*{3cm}
	\LARGE
	\textbf{Benutzerhandbuch}\\
	\Huge
	\vspace*{1cm}
	\textsf{\textbf{XXXXXXXXXXXXXXXXXXXX}}\\
	\vspace*{3cm}
	
	\vfill
	\normalsize
	%\newcolumntype{x}[1]{>{\raggedleft\arraybackslash\hspace{0pt}}p{#1}}
	%\begin{tabular}{x{6cm}p{7.5cm}}
	%	\rule{0mm}{5ex}{\textbAutor:} & Geert Martin Ijewski
	%\end{tabular} 
\end{center}
\pagebreak

\section{Einleitung}
Im folgenden wird die Bedienung der verschiedenen Teile des Systems erkl{\"{a}}rt. Hierbei wird zuerst auf das Simulationsprogramm und dann auf
den restlichen Code inklusive Benutzerschnitstelle eingegangen.

\section{Die Simulation}
Das Simulationsprogramm wurde mithilfe der Unity Engine entwickelt, die eingesetzten Skripte wurden
dabei in C\# geschrieben. Dem Benutzer wird der Simulationsstatus angezeigt und es wird die M{\"{o}}glichkeit
gegeben mithilfe einer Fernsteuerung eines Roboters in diese einzugreifen. Die Voter k{\"{o}}nnen sich
mit der Simulation verbinden und empfangen dann die Weltstatusinformationen und k{\"{o}}nnen Steuerbefehle
absetzen.

\subsection{Kompilierung}
Um {\"{A}}nderungen an der Simulation durchzuf{\"{u}}hrend, oder sie nur auf eine andere Plattform
zu portieren ist der Unity Editor 2017 n{\"{o}}tig; das Projekt ist nicht r{\"{u}}ckw{\"{a}}rtskompatibel zu {\"{a}}lteren Versionen. Im Unity Editor
ist eine IDE enthalten, mit der es m{\"{o}}glich ist den C\# Code zu kompilieren, bei der Installation wird allerdings die Installation von Visual Studio
2017 vorgeschlagen. Diese f{\"{u}}gt sich (mit den richtigen Plugins) besser in das Geschehen ein, so das es zum Beispiel m{\"{o}}glich ist, im Code
Breakpointe zu setzen; falls dieser dann getroffen wird, wird das Spiel pausiert und kann debuggt werden (also k{\"{o}}nnen die Variablen eingesehen
und ver{\"{a}}ndert werden und es ist m{\"{o}}glich durch den Quellcode in Einzelschritten durchzugehen).

Da die \href{https://github.com/mhowlett/NNanomsg}{NNanomsg Bibliothek} genutzt wird, um mit den Votern zu kommunizieren, muss diese auch der Simulation beigelegt werden. 
Dazu werden jeweils zwei Unternordner, einer namens x86, einer namens x64 angelegt in welche dann die jeweiligen vorkompilierten Dateien gelegt werden. F{\"{u}}r die
Benutzung unter Windows sind dies .DLL Dateien, bei Linux sind es .so Dateien.

\todo{iwo hochladen?}

\subsection{Installation}
\todo{}

\subsection{Einstellungen}
Die Simulationsparameter sollen vom Benutzer {\"{a}}nderbar sein, alle Einstellungsm{\"{o}}glichkeiten werden in verschiedenen JSON Dateien (mit festem Namen) aufgelistet.

Die Parameter f{\"{u}}r die Fehlerinjektion k{\"{o}}nnen in der Datei `fault\_injector.json` eingestellt werden. Dort ist es m{\"{o}}glich, f{\"{u}}r die einzelnen Motoren
der Roboter die Fehlerwahrscheinlichkeiten (ob f{\"{u}}r tempor{\"{a}}re/dauerhafte oder \textit{stuck-at}/komplett funktionsunt{\"{u}}chtig) einzustellen, siehe
Beispiel. Da Fehler oft nach dem Modell der Badewannenkurve auftreten ist es in der Konfigdatei m{\"{o}}glich, eine Fehlerwahrscheinlichkeit und die zeitliche L{\"{a}}nge
des ersten Abschnitts dieser Kurve anzugeben.

Desweiteren sollen auch die physikalsichen Parameter der Simulation an sich frei einstellbar sein; dies geschieht in `phys.json`. Dort k{\"{o}}nen, neben den Schwingkonstanten
$\omega_t$ und $\delta$, auch der Radius der Platte, der Maximalkippwinkel und weitere Einstellungen wie das Basisgewicht eines Roboters oder der Zeitabstand zwischen dem
Senden der Weltstatusinformationen eingestellt werden.

Diese Dateien werden beim Start des Programmes gelesen und ausgewertet. Zur Laufzeit ist keine {\"{A}}nderung der Parameter m{\"{o}}glich, hierf{\"{u}}r muss das Programm
neu gestartet werden.

\subsection{Bedienung}
Nach dem starten der Simulation k{\"{o}}nnen sich die Voter verbinden. Dabei wird ein Roboter erstellt und auf der Platte abgesetzt. Dieser kann nun durch den Voter
gesteuert werden; es ist auch m{\"{o}}glich den Roboter fernzusteuern -- mit der Escapetaste wird die Fernsteuerung eingeschaltet. Der ausgew{\"{a}}hlte Roboter kann
dann mit den Pfeiltasten bewegt werden. Mithilfe der Tabulatortaste ist es m{\"{o}}glich den fernzusteuernden Roboter zu wechseln. Der Status der Fernsteuerung (an/aus)
wird in der Mitte des Bildschirms angezeigt.

Erst wenn sich zwei Roboter auf der Platte befinden kippt diese auch. Die Kippwinkel werden in der Mitte des Bildschirms als Zahl angezeigt. Desweiteren gibt es in der
linken oberen Ecke eine Anzeige um einzusch{\"{a}}tzen wie "kritisch" die Platte schon gekippt ist. Dies wird durch verschiedenfarbige, in einander liegenden Kreisen
symbolisiert. Dabei zeigt der innerste, gr{\"{u}}ne, an das die Platte gut ausbalanciert ist, w{\"{a}}hrend der {\"{a}}usserste, rote das Gegenteil bedeutet.


\section{Der Code des Interfaces, inklusive Beispielimplementation}
Der restliche Code ist in einem git repository und wird mithilfe von CMake gebaut. Der Code hat einige Bibliotheken
diese sind als in git als Untermodule eingebunden, k{\"{o}}nnen also leicht geladen werden.
Die meisten Libraries kompilieren und k{\"{o}}nnen ohne Probleme gelinkt werden, allerdings muss bei googletest aufgepasst werden das es und die Testprogramme mit den
gleichen Compiler- und Linkerversionen kompiliert wurden. Sonst kann es zu Unterschieden in der ABI kommen, wodurch unvorhersehbare Fehler auftreten k{\"{o}}nnen. Am einfachsten
ist es googletest nicht zu installieren, sondern die lokale Version im git Submodule zu benutzen.

F{\"{u}}r den kompletten Kompiliervorgang m{\"{u}}ssen folgende Befehle ausgef{\"{u}}hrt werden:
\begin{lstlisting}[frame=single, language=Bash] 
git clone https://bitbucket.com/gmij/bachelor.git # alternativ von CD nehmen
cd bachelor
git submodule update --recursive --remote
mkdir build && cd build
cmake ../code
make
\end{lstlisting}

Nach erfolgreicher Kompilierung k{\"{o}}nnen Voter und Controller gestartet werden. Die Reihenfolge ist dabei unerheblich; dem Voter muss als erstes die Adresse der Simulation
{\"{u}}bergeben werden und als zweiten Parameter das Interface, auf dem die Nachrichten f{\"{u}}r die Controller ({\"{u}}ber broadcast) gesendet werden sollen. Dem Controller
wird als Parameter nur das Interface {\"{u}}bergeben. Dies ist nur eine Beispielimplementation, daher wurde kein vollst{\"{a}}ndiges parsen der Kommandozeilenargumente
implementiert, sondern sie m{\"{u}}ssen in einer festen Reihenfolge eingegeben werden.

\subsection{Abh{\"{a}}nigkeiten}
\todo{}

\subsection{Interface}
Das Interface selbst befindet sich in der Bibliothek libworld. Dies ist eine statische Bibliothek, die dann von anderen Programmen einfach genutzt werden
gelinkt werden kann. world.h ist das dazugeh{\"{o}}rige Headerfile mit den Funktionsdeklarationen.

libworld braucht einige weitere Bibliotheken, zum Beispiel librpc und libficfg. Durch die Benutzung von CMake werden diese allerdings automatisch mit gelinkt.

\subsection{Beispielimplementation}
Die Aufgabe des Voters ist es die Weltstatusinformationen anzunehmen, an die Controller zu senden und die Steuerkommandos zu sammeln und dann den Roboter in
der Simulation zu steuern. Eine Beispielimplementation befindet sich im Ordner voter. In der Commitversion b8e7e5a8764002eeee07a3451745483f5ef00cc7 ist eine
Minimalimplementierung enthalten, die dann von den Studenten erweitert werden kann.

Die Beispielimplementation des Controllers (zusammen mit libalgo) dient nur zum Beweis der Machbarkeit und sollte den Studierenden nicht zur Verf{\"{u}}gung
gestellt werden.

\subsection{Unittests und Testprogramme}
Im Verlauf der Programmierung wurden einige Testprogramme geschrieben welche die Entwicklung vereinfachten. Beispielsweise gibt es das movement Programm das
einen Roboter konstant in eine bestimmte Richtung fahren l{\"{a}}sst, womit getestet wurde ob das \textit{differential steering} korrekt implementiert wurde.

Auch gibt es Unit-Tests um zu verifizieren das bestimmte Funktionalit{\"{a}}ten auch nach {\"{A}}nderungen erhalten bleiben. Teilweise sind diese Teil der
Beispielimplementation (wie die Unit-tests f{\"{u}}r libnetwork und libecc), teilweise aber auch Bestandteil des Interfaces wie die Unittests f{\"{u}}r librpc.
Alle Tests k{\"{o}}nnen mit dem Shellskript "run-tests.sh" ausgef{\"{u}}hrt werden und geben dann den Status der einzelenen Teste aus.

\end{document}

