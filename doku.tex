\documentclass[
    12pt,
    bibliography=totoc,
    ngerman
]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[ngerman]{babel}
%\usepackage[decimalsymbol=comma]{siunitx}

%\usepackage[style=ieee]{biblatex}
\usepackage{setspace}
\PassOptionsToPackage{hyphens}{url}
\usepackage[hidelinks,linktoc=all,pdfusetitle]{hyperref}
\usepackage[ampersand]{easylist}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{tabu}
\usepackage{booktabs}
\usepackage{mathtools}
\usepackage{csquotes}
\usepackage{lscape}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{rotating}
\usepackage{subcaption}
\usepackage{amssymb} % for \checkmark
\usepackage{alltt}
\usepackage[nottoc,numbib]{tocbibind}
\usepackage{todonotes}

\setstretch{1.433} %entspricht 1,5 in Word 
\graphicspath{{images/}}
\MakeOuterQuote{"}
\pagestyle{fancy}
\lstset{frame=single,breaklines=true}
%\setcounter{biburllcpenalty}{7000}
%\setcounter{biburlucpenalty}{8000}

\newcommand{\includevisio}[2][]{\includegraphics[clip, trim=1cm 1cm 1cm 1cm, #1]{#2}}

\titlehead{{\large Fachhochschule S{\"{u}}dwestfalen} \\ Fachbereich f{\"{u}}r Elektrotechnik und Informationstechnik \\ Studiengang Technische Informatik}
\subject{\vspace{2cm} Bachelorarbeit}
\title{XXXXXXX}
\author{Geert Martin Ijewski}
\publishers{\vfill Betreuer: Prof. Dr.-Ing. habil. Jan Richling}

\begin{document}

\maketitle
\thispagestyle{empty}

\clearpage
\tableofcontents
\listoffigures
%\addcontentsline{toc}{section}{\listfigurename}
\listoftables

\clearpage
\section{Einf{\"{u}}hrung}
\todo{Renderbild, Bild von der Ausgabe?}

\paragraph{Motivation} \todo{...}

\paragraph{Simulation} Die simulierte Welt besteht aus einer kreisf{\"{o}}rmigen Platte. Auf dieser k{\"{o}}nnen bis zu $N$ Roboter und $1$ F{\"{u}}llstation
platziert werden. Die Summe ihrer Gewichte kippt die Platte - sind die Gewichte zu ungleichm{\"{a}}{\ss}ig verteilt, kippt
die Platte und die Simulation endet.

Die Roboter k{\"{o}}nnen sich frei auf der Platte bewegen, verbrauchen dabei aber Energie und m{\"{u}}ssen diese dann irgendwann
an der F{\"{u}}llstation auff{\"{u}}llen. Auch wenn die Roboter sich nicht bewegen, verbrauchen sie Energie (allerdings weniger
schnell).

Kontrolliert werden die Roboter von bis zu $M$ $(M \geq N)$ Kontrollern. Einer oder mehr Kontroller stimmen sich ab,
so dass:
\begin{itemize}
\item die Roboter ihre Energie immer rechtzeitig auff{\"{u}}llen
\item die Roboter nicht kollidieren
\item die Platte nicht kippt
\end{itemize}

Dieser Abstimmungsvorgang sollte fehlertolerant implementiert werden. (Abh{\"{a}}ngig vom Verh{\"{a}}ltniss der Anzahl der Kontroller zur
Anzahl der Roboter k{\"{o}}nnen verschiedene Stufen der Fehlertoleranz erreicht werden.\cite[s.149]{Werner00}) Teil dieser Bachelorarbeit ist eine
Beispielimplementation, die auch mithilfe eines Fehlerinjektors getestet wurde.

\todo{anforderungen?}

\paragraph{Nutzung durch die Studenten} \todo{Einleitung}
\todo{interface}

\paragraph{Evaluation}

\clearpage
\section{Vorherige Arbeite}


\clearpage
\section{Die Welt}
Die simulierte Welt besteht aus den Robotern die von den Studierenden gesteuert werden sollen, einer F{\"{u}}llstation an der die Robter Energie tanken k{\"{o}}nnen und
der Welt, einer kreisf{\"{o}}rmigen, kippbaren Platten, auf der diese Objekte platziert werden und sich bewegen k{\"{o}}nnen.

Simuliert wird die Welt mit der Unity3D game engine \todo{cite}. Diese erm{\"{o}}glicht es plattformunabh{\"{a}}nige Spiele oder, in diesem Fall, Simulationen zu schreiben.
Dabei stellt sie, unter anderem, eine Physikengine, eine Grafikengine und eine Schnitstelle zum scripten dieser bereit. 

\subsection{Unity3D}
\paragraph{Grafikengine}
Die in Unity enthaltene Grafikengine ist eine vollwertige 3D-Grafikengine, die es erm{\"{o}}glicht professionelle Videospiele zu programmieren. In dieser Arbeit wird nur
ein kleiner Teil der Funktionalit{\"{a}}t benutzt; komplexere Features wie die Anzeige von Rauch oder realistischem Wasser sind nicht in der Simulation enthalten.

Notwendig ist es aber das die verschiedenen Objekte in der simulierten Welt in 3D zu sehen sind und sich die Kamera bewegen l{\"{a}}sst um das simulierte Geschehen zu
verfolgen. Dies geh{\"{o}}rt zur Grundfunktionalit{\"{a}}t und muss nicht extra implementiert werden.

\paragraph{Physikengine}
Ein integraler Teil moderner Videospiele ist eine realistische physikalische Umgebung. Dies wird durch die Physikengine von Unity3D erm{\"{o}}glicht, die in dieser
Arbeit wichtige Funktionalit{\"{a}}t ist
\begin{itemize}
\item die Kollisionserkennung, einerseits um zu bestrafen wenn Roboter in einander fahren und auch zur Erkennung des Kontaktes mit der F{\"{u}}llstation
\item die Bewegung der Objekte in der Welt zu simulieren, abh{\"{a}}ngig von Gewicht und Geschwindigkeit
\end{itemize}

\paragraph{Scripting}
Alle Elemente der Unity3D Engine k{\"{o}}nnen vom Programmierer gesteuert werden. Um dies zu erm{\"{o}}glichen ist es aus dem Skript heraus m{\"{o}}glich alle Eigenschaften
der Objekte \footnote{dies beinhaltet nicht nur die Roboter und F{\"{u}}llstationen sondern auch die Kamera oder statische Objekte wie Mauern} auszulesen und zu manipulieren.

Beispielsweise wurde der F{\"{u}}llstation ein Skript zugeordnet das solange ein Objekt mit dieser kollidiert testet ob dies Objekt ein Roboter ist, und falls dies der Fall ist,
den Roboter auftankt.

\subsection{Die Roboter}\label{robot}
In der simulierten Welt k{\"{o}}nnen sich bis zu $N$ Roboter bewegen. Diese bewegen sich aber nicht selbstst{\"{a}}ndig, sondern werden von den Controllern ferngesteurt.
\paragraph{Grafisches Modell} \todo{selbst designen? ball? }

\paragraph{Physikalisches Modell}
Ein Roboter wird dabei beschrieben durch seine Position und Gewicht
$ N_i = \bigl(\begin{smallmatrix} x(i) \\ y(i) \\ w(i) \end{smallmatrix}\bigr)$ und
seinen Geschwindigkeitsvektor
$ V_i = \bigl(\begin{smallmatrix} \Delta x \\ \Delta y \end{smallmatrix}\bigr)$.

Das Gewicht des Roboters ist abh{\"{a}}ngig vom Grundgewicht des Roboters und seinem momentanen F{\"{u}}status: $ w(N_i) = 1 + e(N_i) * 0.03 $.

Dabei kann der Roboter sich frei in alle Richtungen bewegen, erreicht aber
maximal eine Geschwindigkeit $ -3 \leq \Delta x \leq 3$, bzw. 
$ -3 \leq \Delta y \leq 3$.
Innerhalb einer Simulationsrunde kann der Roboter seine Geschwindigkeit, pro
Richtung, nur um 1 Geschwindigkeitseinheit {\"{a}}ndern.


Die Roboter haben einen Energiespeicher der mit maximal 100 Energieeinheiten
aufgeladen werden kann und verbrauchen diese Energie, ob beim Fahren oder
Stillstand. Dabei verbrauchen sie pro Runde ohne Bewegung immer eine Energieeinheit und zus{\"{a}}tzlich, abh{\"{a}}ngig von der Geschwindigkeit, Energie f{\"{u}}r die Bewegung:
$$ e(N_i, n{\"{a}}chste Runde) = e(N_i, diese Runde) - 1 - |V_i| $$

\subsection{Die F{\"{u}}llstation}\label{fuelstation}
Innerhalb der Welt muss eine F{\"{u}}llstation platziert werden, um den Roboter die M{\"{o}}glichkeit zu geben sich aufzuladen. Auch diese wird durch ihren Vektor $ F = \bigl(\begin{smallmatrix} x \\ y \\ w \end{smallmatrix}\bigr)$ beschrieben. Eine F{\"{u}}llstation hat dabei ein festes Gewicht: $ w(F) = 5 $.

Diese wird vor Simulationsbeginn platziert und bewegt sich im weiteren Verlauf nicht.
Falls sich ein Roboter an die Platte heranbewegt, also gilt: 
$$ |\bigl(\begin{smallmatrix} x(i) \\ y(i) \end{smallmatrix}\bigr) - \bigl(\begin{smallmatrix} x(F) \\ y(F) \end{smallmatrix}\bigr)| \leq |\bigl(\begin{smallmatrix} 1 \\ 1 \end{smallmatrix}\bigr)| $$
wird dieser Roboter aufgeladen. Die Ladefunktion ist hier eine einfache Gerade:
$$ e(N_i, n{\"{a}}chste Runde) = max((e(N_i, diese Runde) + 10, 100)  $$


\subsection{Die Platte}\label{plate}
Die simulierte Welt besteht aus einer 100 Einheiten gro{\ss}en kreisf{\"{o}}rmigen Platte, die sich, basierend auf den Gewichten welche sich auf ihr befinden, kippt.
Die Kr{\"{a}}fte/Gewichte (der Objekte, also der F{\"{u}}llstation und aller Roboter) die auf die Platte wirken, k{\"{o}}nnen in ihren X und Y Koordinaten getrennt betrachtet und in das Hebelgesetz eingesetzt werden. Der Druck
der durch dieses berechnet wird kann dann benutzt werden um den Kippwinkel zu errechnen.
\todo{herleitung?}

F{\"{u}}r den Vektor der die in Links-Rechts wirkende Kr{\"{a}}fte beschreibt, gilt:
$$ V_{LinksRechts} = \begin{pmatrix}x(F) \\ w(F) \end{pmatrix} + \sum_{i=0}^{|N|} \begin{pmatrix} x(N_i) \\ w(N_i) \end{pmatrix} $$
$$ cos(V_{LinksRechts}) = \beta = W_{LinksRechts} $$

Das gleiche gilt f{\"{u}}r die Kr{\"{a}}fte die beschreiben wie die Platte nach Vorne-Hinten gekippt wird:
$$ V_{VorneHinten} = \begin{pmatrix}y(F) \\ w(F) \end{pmatrix} + \sum_{i=0}^{|N|} \begin{pmatrix} y(N_i) \\ w(N_i) \end{pmatrix} $$
$$ cos(V_{VorneHinten}) = \alpha = W_{VorneHinten} $$

\clearpage
\section{Netzwerk}\label{network}
\todo{Einleitung}
wer, in welchem drin ist. \todo{aufteilung im netzwerk als Bild}

\clearpage
\section{Interface f{\"{u}}r die Studenten}\label{interface}
Damit die Studenten sich auf die Implementierung der Fehlertoleranz konzentrieren k{\"{o}}nnen gibt es Interfaces. \todo{umformulieren} 
Im ganzen System gibt es drei Schnittstellen:
\begin{itemize}
\item Die Schnittstelle zwischen Controller und Voter
\item Die Schnittstelle zwischen Voter und Roboter
\item Die Schnittstelle zwischen Controller und simulierter Welt \todo{oder Voter und simulierter Welt und dann an Controller senden?}
\end{itemize}

\paragraph{Die Schnittstelle zwischen Controller und Voter} ist komplett den Studenten {\"{u}}berlassen.

\paragraph{Die Schnittstelle zwischen Voter und Roboter} wird {\"{u}}ber die Welt geroutet, damit die Welt kontrollieren kann das ein
Roboter sich pro Runde nur einmal bewegt oder dreht. Die Schnittstelle selbst besteht aus den Funktionen:
\begin{lstlisting}[frame=single, language=c++] 
int moveRobot(const int32_t robot, const Position& diffVector);
void update();
\end{lstlisting}


\clearpage
\section{Fehlerinjektion}

\clearpage
\section{Referenzimplementation}
\subsection{Voter}\label{voter}
\subsection{Consensus algorithm}
\paragraph{Schutzmassnahmen gegen omission failure}
\paragraph{bla bla bla}


\clearpage
\section{Evaluation}


\clearpage
%\nocite{*} % alle unbenutzen Literatureintr{\"{a}}ge trotzdem anzeigen
\bibliographystyle{plain}
%\addbibresource{lit.bib}
\bibliography{../lit}

\end{document}
