\documentclass[
    12pt,
    bibliography=totoc,
    ngerman
]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[ngerman]{babel}
%\usepackage[decimalsymbol=comma]{siunitx}

%\usepackage[style=ieee]{biblatex}
\usepackage{setspace}
\PassOptionsToPackage{hyphens}{url}
\usepackage[hidelinks,linktoc=all,pdfusetitle]{hyperref}
\usepackage[ampersand]{easylist}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{tabu}
\usepackage{booktabs}
\usepackage{mathtools}
\usepackage{csquotes}
\usepackage{lscape}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{rotating}
\usepackage{subcaption}
\usepackage{amssymb} % for \
\usepackage{alltt}
\usepackage[nottoc,numbib]{tocbibind}
\usepackage{todonotes}

\setstretch{1.433} %entspricht 1,5 in Word 
\graphicspath{{images/}}
\MakeOuterQuote{"}
\pagestyle{fancy}
\lstset{frame=single,breaklines=true}
%\setcounter{biburllcpenalty}{7000}
%\setcounter{biburlucpenalty}{8000}

\newcommand{\xmark}{\text{\sffamily X}} % gegensymbol zu \checkmark

\newcommand{\includevisio}[2][]{\includegraphics[clip, trim=1cm 1cm 1cm 1cm, #1]{#2}}

\titlehead{{\large Fachhochschule S{\"{u}}dwestfalen} \\ Fachbereich f{\"{u}}r Elektrotechnik und Informationstechnik \\ Studiengang Technische Informatik}
\subject{\vspace{2cm} Bachelorarbeit}
\title{XXXXXXX}
\author{Geert Martin Ijewski}
\publishers{\vfill Betreuer: Prof. Dr.-Ing. habil. Jan Richling}

\begin{document}

\maketitle
\thispagestyle{empty}

\clearpage
\tableofcontents
\listoffigures
%\addcontentsline{toc}{section}{\listfigurename}
\listoftables

\clearpage
\section{Einf{\"{u}}hrung}
\todo{Renderbild, Bild von der Ausgabe?}

\paragraph{Motivation} \todo{...}

\paragraph{Simulation} Die simulierte Welt besteht aus einer kreisf{\"{o}}rmigen Platte. Auf dieser k{\"{o}}nnen bis zu $N$ Roboter und $1$ F{\"{u}}llstation
platziert werden. Die Summe ihrer Gewichte kippt die Platte - sind die Gewichte zu ungleichm{\"{a}}{\ss}ig verteilt, kippt
die Platte und die Simulation endet.

Die Roboter k{\"{o}}nnen sich frei auf der Platte bewegen, verbrauchen dabei aber Energie und m{\"{u}}ssen diese dann irgendwann
an der F{\"{u}}llstation auff{\"{u}}llen. Auch wenn die Roboter sich nicht bewegen, verbrauchen sie Energie (allerdings weniger
schnell).

Kontrolliert werden die Roboter von bis zu $M$ $(M \geq N)$ Kontrollern. Einer oder mehr Kontroller stimmen sich ab,
so dass:
\begin{itemize}
\item die Roboter ihre Energie immer rechtzeitig auff{\"{u}}llen
\item die Roboter nicht kollidieren
\item die Platte nicht kippt
\end{itemize}

Dieser Abstimmungsvorgang sollte fehlertolerant implementiert werden. (Abh{\"{a}}ngig vom Verh{\"{a}}ltniss der Anzahl der Kontroller zur
Anzahl der Roboter k{\"{o}}nnen verschiedene Stufen der Fehlertoleranz erreicht werden.\cite[s.149]{Werner00}) Teil dieser Bachelorarbeit ist eine
Beispielimplementation, die auch mithilfe eines Fehlerinjektors getestet wurde.

\todo{anforderungen?}

\paragraph{Nutzung durch die Studenten} \todo{Einleitung}
\todo{interface}

\paragraph{Evaluation}

\clearpage
\section{Vorherige Arbeiten}
Da das Ziel dieser Arbeit die Entwicklung einer Aufgabe zur Verdeutlichung der Prinzipen Ausfallsicherer Systeme ist, wird ein kurzer {\"{U}}berblick {\"{u}}ber
bereits bestehende Systeme dieser Arbeit gegeben.

\subsection{Die balancierenden Roboter}
Um die M{\"{o}}glichkeiten des in \cite{Werner00} neu entwickelten CORE Systems zu testen wurde, an der Humboldt Universit{\"{a}}t Berlin, in Zusammenarbeit
mit Daimler Benz, eine Simulation {\"{a}}hnlich dieser entwickelt. Zu dieser wurde dann sp{\"{a}}ter ein echter physikalischer Roboter hinzugef{\"{u}}gt.

Im Gegensatz zu diesem System musste es, zus{\"{a}}tzlich zur nicht-funktionalen Eigenschaft Ausfallsicherheit, auch echtzeitf{\"{a}}hig sein.

\paragraph{Systemaufbau} Die Simulation und die Controller l{\"{a}}ufen auf dem NeXTStep Betriebssystem und kommunizieren {\"{u}}ber CORBA miteinander\cite{predictablecorba}, w{\"{a}}hrend
das Anzeigeprogramm Java basiert ist und z.B. auf einem Windowsrechner laufen kann.

\todo{mehr}

\paragraph{Evaluation} \todo{warum meins doller ist. Nicht als Lernobjekt gedacht? Graphisch in die Jahre gekommen. Einarbeitungszeit in CORBA, nicht
zumutbar?}

\subsection{Die ausfallsichere Heizung}
Eine weitere {\"{U}}bungsaufgabe wurde im Sommersemester 2016 an der FH S{\"{u}}dwestfalen entwickelt. Das Ziel ist es, mithilfe zwei Heizk{\"{o}}rpern, zweier
L{\"{u}}fter und 3 Temperatursensoren (jeweils einer an dem L{\"{u}}fter und Heizk{\"{o}}rper, einer im Ausgangsluftstrom) eine Temperatur zu regeln.
Das Gesamtsystem ist Y-f{\"{o}}rmig aufgebaut; an den Armen des Ypsilon befindet sich jeweils ein Heizk{\"{o}}rper und ein L{\"{u}}fter, am dem Punkt an dem sich
die Arme treffen ist eine Klappe die den Luftstrom, nach vorne hinaus, blockieren kann (diese Luft wird dann nach oben abgeleitet).

\paragraph{Systemaufbau} Die verschiedenen Komponenten h{\"{a}}ngen an drei verschiedenen Rechnern\footnote{jeweils mit eigenem Temperatursensor}:
\begin{itemize}
\item einem Rechner der die Heizk{\"{o}}rper steuert
\item einem Rechner der die L{\"{u}}fter steuert
\item einem Rechner der die Klappe steuert
\end{itemize}

Diese Rechner k{\"{o}}nnen {\"{u}}ber UDP und I\textsuperscript{2}C miteinander kommunizieren. Diese Kommunikationswege, oder sogar ganze Rechner, k{\"{o}}nnen
allerdings zu jedem Zeitpunkt ausfallen -- es ist also notwendig das System ausfallsicher zu designen.

\todo{Mehr? Weiss nicht, ich will ja nicht unsere Implementation beschreiben}

\paragraph{Evaluation} Dieses System hat allerdings physikalische Beschr{\"{a}}nkungen die es sehr
tr{\"{a}}ge, und damit als Vorf{\"{u}}hrobjekt zum Beispiel f{\"{u}}r Schulklassen,
ungeeignet machen. Dies wird noch dadurch verst{\"{a}}rkt das es keinerlei
Interaktionsm{\"{o}}glichkeiten mit dem System gibt.

\todo{man muss mit mehr als 3 Rechnern arbeiten?}

\clearpage
\section{Konzept}
Sehr high level, Bild vom Systemaufbau

\clearpage
\section{3D Engine}
warum ueberhaupt noetig

\subsection{Auswahl}
\subsection{Unity}
Unity ist eine von Unity Technologies entwickelte \textit{game engine} die 2005 f{\"{u}}r Macintosh entwickelt wurde und in der Zwischenzeit auf 27 Plattformen portiert wurde.

In dieser Arbeit wird es benutzt um die Welt und die Interkationen zwischen den Objekten zu simulieren und diese auch anzuzeigen. Mithilfe einer Scriptingschnittstelle kann das Geschehen modifiziert werden, z.B. kann die Welt
abh{\"{a}}ngig von der Position und den Gewichten der Objekt gekippt werden oder die Kamera durch Tastatureingaben bewegt werden.

\subsection{Grafikengine}
Die in Unity enthaltene Grafikengine ist eine vollwertige 3D-Grafikengine, die es erm{\"{o}}glicht professionelle Videospiele zu programmieren. In dieser Arbeit wird nur
ein kleiner Teil der Funktionalit{\"{a}}t benutzt; komplexere Features wie die Anzeige von Rauch oder realistischem Wasser sind nicht in der Simulation enthalten.

Notwendig ist es aber das die verschiedenen Objekte in der simulierten Welt in 3D zu sehen sind und sich die Kamera bewegen l{\"{a}}sst um das simulierte Geschehen zu
verfolgen. Dies geh{\"{o}}rt zur Grundfunktionalit{\"{a}}t und muss nicht extra implementiert werden.

\subsection{Physikengine}
Ein integraler Teil moderner Videospiele ist eine realistische physikalische Umgebung. Dies wird durch die Physikengine von Unity erm{\"{o}}glicht, die in dieser
Arbeit wichtigen Funktionalit{\"{a}}ten sind:

\begin{itemize}
\item die Kollisionserkennung, einerseits um zu bestrafen wenn Roboter in einander fahren und auch zur Erkennung des Kontaktes mit der F{\"{u}}llstation
\item die Bewegung der Objekte in der Welt zu simulieren, abh{\"{a}}ngig von Gewicht und Geschwindigkeit
\end{itemize}

\subsection{Scripting}
Alle Elemente der Unity Engine k{\"{o}}nnen vom Programmierer gesteuert werden, unterst{\"{u}}tzt werden dabei sie Skriptsprachen C\#, JavaScript und Boo.\cite{wiki:unity} Um dies zu erm{\"{o}}glichen ist es aus dem Skript heraus m{\"{o}}glich alle Eigenschaften
der Objekte \footnote{dies beinhaltet nicht nur die Roboter und F{\"{u}}llstationen sondern auch die Kamera oder statische Objekte wie Mauern} auszulesen und zu manipulieren.

Beispielsweise wurde der F{\"{u}}llstation ein Skript zugeordnet das solange ein Objekt mit dieser kollidiert testet ob dies Objekt ein Roboter ist, und falls dies der Fall ist,
den Roboter auftankt. Ein anderes Skript bewegt die Kamera abh{\"{a}}ngig von den Tastatureingaben des Benutzers.

\clearpage
\section{Netzwerklibrary}
\subsection{Auswahl}
broadcast, publish-suscribe

\begin{table}[h]
\centering
\begin{tabu}{c | c | c | c | p{5cm}}
	\toprule
	Name & RPC & Publish-Suscribe & C++ Runtime & andere Sprachen \\
	\midrule
	grpc\cite{grpc} & \checkmark & \xmark & \xmark & C\#, Python, Java, ... \\
	ZeroMQ\cite{zeromq} & \xmark & \checkmark & \xmark & C\#, Python, Java, ... \enquote{40+ languages} \\
	nanomsg\cite{nanomsg} & \xmark & \checkmark & \checkmark & C\#, Python, Java, ... (25 Sprachen) \\
	\bottomrule
\end{tabu}
\caption{Anforderungen an die Netwerkbibliothek}
\end{table}

\subsection{nanomsg}
dann und dann geschrieben, soll halt bestimmte oft gebrauchte Ubertragungsarten implementieren

\paragraph{{\"{U}}bertragungsarten}
\subparagraph{Request-Reply}
\subparagraph{Publish-Suscribe}
Kriterien: r{\"{a}}umlich, zeitlich getrennt, asynchron m{\"{o}}glich \cite{pubsub}
\todo{bild}

\clearpage
\section{Serialisierung}
Verschiedene Sprachen, binaerprotokoll ist dann tricky

\subsection{Auswahl}
\subsection{msgpack}
dann und dann geschrieben, von wem, language bindings, soll sehr kleine Nachrichten erstellen

\paragraph{Grundlegendes}
\paragraph{Integer}
\paragraph{Fixed Size Arrays}

\clearpage
\section{Die Welt}
Die simulierte Welt besteht aus den Robotern die von den Studierenden gesteuert werden sollen, einer F{\"{u}}llstation an der die Robter Energie tanken k{\"{o}}nnen und
der Welt, einer kreisf{\"{o}}rmigen, kippbaren Platten, auf der diese Objekte platziert werden und sich bewegen k{\"{o}}nnen.

Simuliert wird die Welt mit der Unity \textit{game engine}. Diese erm{\"{o}}glicht es plattformunabh{\"{a}}nige Spiele oder, in diesem Fall, Simulationen zu schreiben.
Dabei stellt sie, unter anderem, eine Physikengine, eine Grafikengine und eine Schnitstelle zum scripten dieser bereit. 

\subsection{Die Roboter}\label{robot}
In der simulierten Welt k{\"{o}}nnen sich bis zu $N$ Roboter bewegen. Diese bewegen sich aber nicht selbstst{\"{a}}ndig, sondern werden von den Controllern ferngesteurt.
\paragraph{Grafisches Modell} \todo{selbst designen? ball? }

\paragraph{Physikalisches Modell}
Ein Roboter wird dabei beschrieben durch seine Position und Gewicht
$ N_i = \bigl(\begin{smallmatrix} x(i) \\ y(i) \\ w(i) \end{smallmatrix}\bigr)$ und
seinen Geschwindigkeitsvektor
$ V_i = \bigl(\begin{smallmatrix} \Delta x \\ \Delta y \end{smallmatrix}\bigr)$.

Das Gewicht des Roboters ist abh{\"{a}}ngig vom Grundgewicht des Roboters und seinem momentanen F{\"{u}}status: $ w(N_i) = 1 + e(N_i) * 0.03 $.

Dabei kann der Roboter sich frei in alle Richtungen bewegen, erreicht aber
maximal eine Geschwindigkeit $ -3 \leq \Delta x \leq 3$, bzw. 
$ -3 \leq \Delta y \leq 3$.
Innerhalb einer Simulationsrunde kann der Roboter seine Geschwindigkeit, pro
Richtung, nur um 1 Geschwindigkeitseinheit {\"{a}}ndern.


Die Roboter haben einen Energiespeicher der mit maximal 100 Energieeinheiten
aufgeladen werden kann und verbrauchen diese Energie, ob beim Fahren oder
Stillstand. Dabei verbrauchen sie pro Runde ohne Bewegung immer eine Energieeinheit und zus{\"{a}}tzlich, abh{\"{a}}ngig von der Geschwindigkeit, Energie f{\"{u}}r die Bewegung:
$$ e(N_i, n{\"{a}}chste Runde) = e(N_i, diese Runde) - 1 - |V_i| $$

\subsection{Die F{\"{u}}llstation}\label{fuelstation}
Innerhalb der Welt muss eine F{\"{u}}llstation platziert werden, um den Roboter die M{\"{o}}glichkeit zu geben sich aufzuladen. Auch diese wird durch ihren Vektor $ F = \bigl(\begin{smallmatrix} x \\ y \\ w \end{smallmatrix}\bigr)$ beschrieben. Eine F{\"{u}}llstation hat dabei ein festes Gewicht: $ w(F) = 5 $.

Diese wird vor Simulationsbeginn platziert und bewegt sich im weiteren Verlauf nicht.
Falls sich ein Roboter an die Platte heranbewegt, also gilt: 
$$ |\bigl(\begin{smallmatrix} x(i) \\ y(i) \end{smallmatrix}\bigr) - \bigl(\begin{smallmatrix} x(F) \\ y(F) \end{smallmatrix}\bigr)| \leq |\bigl(\begin{smallmatrix} 1 \\ 1 \end{smallmatrix}\bigr)| $$
wird dieser Roboter aufgeladen. Die Ladefunktion ist hier eine einfache Gerade:
$$ e(N_i, n{\"{a}}chste Runde) = max((e(N_i, diese Runde) + 10, 100)  $$


\subsection{Die Platte}\label{plate}
Die simulierte Welt besteht aus einer 100 Einheiten gro{\ss}en kreisf{\"{o}}rmigen Platte, die sich, basierend auf den Gewichten welche sich auf ihr befinden, kippt.
Die Kr{\"{a}}fte/Gewichte (der Objekte, also der F{\"{u}}llstation und aller Roboter) die auf die Platte wirken, k{\"{o}}nnen in ihren X und Y Koordinaten getrennt betrachtet und in das Hebelgesetz eingesetzt werden. Der Druck
der durch dieses berechnet wird kann dann benutzt werden um den Kippwinkel zu errechnen.
\todo{herleitung?}

F{\"{u}}r den Vektor der die in Links-Rechts wirkende Kr{\"{a}}fte beschreibt, gilt:
$$ V_{LinksRechts} = \begin{pmatrix}x(F) \\ w(F) \end{pmatrix} + \sum_{i=0}^{|N|} \begin{pmatrix} x(N_i) \\ w(N_i) \end{pmatrix} $$
$$ cos(V_{LinksRechts}) = \beta = W_{LinksRechts} $$

Das gleiche gilt f{\"{u}}r die Kr{\"{a}}fte die beschreiben wie die Platte nach Vorne-Hinten gekippt wird:
$$ V_{VorneHinten} = \begin{pmatrix}y(F) \\ w(F) \end{pmatrix} + \sum_{i=0}^{|N|} \begin{pmatrix} y(N_i) \\ w(N_i) \end{pmatrix} $$
$$ cos(V_{VorneHinten}) = \alpha = W_{VorneHinten} $$

\clearpage
\section{Systemaufbau}
\todo{alles neu}
Das ganze System besteht aus verschiedenen Komponenten, die teilweise sogar in unterschiedlichen Netzwerken h{\"{a}}ngen. 

\subsection{Netzwerk}\label{network}
Die Fehlertoleranz dieses Systems wird durch eine r{\"{a}}umliche Redudanz erreicht. Die verschiedenen Teile des Systems sind {\"{u}}ber ein Ethernetnetzwerk miteinander verbunden und benutzen dieses
f{\"{u}}r die Konsensbildung und um Informationen {\"{u}}ber den momentanen Status der Simulation zu bekommen.

Allerdings ist ein Teil der Systemkomponenten in einem Netzwerk das durch eine Fehlerinjektion Pakete verf{\"{a}}lscht, verschwinden l{\"{a}}st oder mehrfach sendet. 
\todo{aufteilung im netzwerk als Bild}

Der Voter jedes simulierten Roboters ist dabei, wie auch die Simulation und die Anzeige, im nichtverf{\"{a}}lschenden Netzwerk. Dies entspricht der Realit{\"{a}}t, in der die physikalischen Bewegungen
des Roboters auch einfach umgesetzt werden. Die Controller allerdings k{\"{o}}nnen sich nicht darauf verlassen das ihre Daten nicht verf{\"{a}}lscht wurden, sie m{\"{u}}ssen also von den Studenten so
programmiert werden das sie mit value faults/message corruption\cite{richling-ass} umgehen k{\"{o}}nnen.

\subsection{VMs}

\subsection{Anzeige}\label{graphics}
Um den Status der Simulation zu verfolgen wird die simulierte Welt und die in ihr enthaltenen Objekte angezeigt. Dies geschieht mit dem gleichen Programm das die Simulation auch tats{\"{a}}chlich
durchf{\"{u}}hrt, die Unity engine stellt die ben{\"{o}}tigte Funktionalit{\"{a}}t f{\"{u}}r beide Aufgaben bereit.

\paragraph{Kamera} Die Sicht auf die simulierte Welt geschieht durch das Unity Objekt Camera. An diese werden verschiedene Skripte angegeh{\"{a}}ngt um z.B. dem Benutzer die M{\"{o}}glichkeit zu
geben die Kamera zu bewegen oder \todo{halt noch irgendwas}.

Die Kamerabewegung kann {\"{u}}ber die Pfeiltasten und WASD gesteuert werden, ein Kippen der Kamera ist nicht implementiert - dies w{\"{u}}rde auch verwirren da damit eventuell der Kippwinkel der
Platte visuell ausgeglichen werden k{\"{o}}nnte.

\paragraph{Lichtquelle} Um die Szene auszuleuchten gibt es ein Spotlight. Dies befindet sich an der Stelle \todo{nachgucken} und scheint mit einem XXXX \textdegree Winkel nach unten.


\clearpage
\section{Interface f{\"{u}}r die Studenten}\label{interface}
Damit die Studenten sich auf die Implementierung der Fehlertoleranz konzentrieren k{\"{o}}nnen gibt es Schnittstellen.
Im ganzen System gibt es zwei Schnittstellen:
\begin{itemize}
\item Die Schnittstelle zwischen Controller und Voter
\item Die Schnittstelle zwischen Voter und Roboter
\end{itemize}

\paragraph{Die Schnittstelle zwischen Controller und Voter} ist komplett den Studenten {\"{u}}berlassen.

\paragraph{Die Schnittstelle zwischen Voter und Roboter} wird {\"{u}}ber die Welt geroutet, damit die Welt kontrollieren kann das ein
Roboter sich pro Runde nur einmal bewegt oder dreht. Die Schnittstelle selbst besteht aus den Funktionen:
\begin{lstlisting}[frame=single, language=c] 
void* connectToWorld();
void detachFromWorld(void* ctx);
typedef void (*TypeGetWorldStatusCallback)(WorldStatus ws, void* optional);
int startProcessingWorldEvents(void* ctx, TypeGetWorldStatusCallback cb, void* optional);
void MoveRobot(void* ctx, int id, int diffX, int diffY);
\end{lstlisting}

Diese wird den Studierenden als kompilierte Library mit einem detailierten Headerfile zur Verf{\"{u}}gung gestellt.

\clearpage
\section{Fehlerinjektion}

\clearpage
\section{Beispielimplementation}
Um das Prinzip dieser Simulation, ob den Studierenden des Moduls Ausfallsichere Systeme oder Besuchern, zu verdeutlichen ist ein Teil der Bachelorarbeit die Implementiereung einer
Beispielimplementation.

\paragraph{Ablauf} Jede Viertelsekunde sendet die Welt Statusinformationen aus. \todo{aeh damit ist es dann doch iwie wieder rundenbasiert?} Diese Informationen werden von allen Controllern empfangen, k{\"{o}}nnen
aber potenziel verf{\"{a}}lscht worden sein. Also wird f{\"{u}}r jedes Objekt der Welt der Konsensalgorithmus ausgef{\"{u}}hrt. Wenn ein Konsens {\"{u}ber den Status der Welt hergestellt wurde, berechnet 
jeder Controller f{\"{u}}r jeden Roboter die n{\"{a}}chste Bewegung. Diese wird dann an den Voter geschickt, der ein einfaches Mehrheitsvotum durchf{\"{u}}hrt und diese Bewegung an die Welt weitergibt.

\subsection{Fehlermodell}
\label{error-model}
\paragraph{Crash failure} Die Controller k{\"{o}}nnen jederzeit ausfallen
\paragraph{Value error} Das Netzwerk kann Pakete verf{\"{a}}lschen, allerdings nur \todo{wie doll halt mein hammingcode ist}

\subsection{Voter}
\label{voter}
Der Roboter kann nur direkt durch den Voter gesteuert werden. Der Voter ist dabei nur daf{\"{u}}r zust{\"{a}}ndig aus den vielen Steuerkommandos die ankommen die Mehrheit zu bilden (\textit{N-modular reduancy}).

\subsection{Controller}
\label{controller}
\paragraph{Algorithmus zur Bestimmung der Bewegung} im buch war das mit vorbestimmten elipsen. ka obs was dolleres gibt.

\subsection{Konsenzalgorithmus}
bla \cite{efficent-consens}. a) nimmt fehlerfreies Netzwerk an -- reicht checksum und nochmal schicken bis geklappt hat? Was ist dann mit omission failure
b) wie man auf mehrere Werte generalisiert ist mir auch noch nicht klar. Eig reichen ja {-1, 0, 1} jeweils f{\"{u}}r x und y



\clearpage
\section{Evaluation}


\clearpage
%\nocite{*} % alle unbenutzen Literatureintr{\"{a}}ge trotzdem anzeigen
\bibliographystyle{plain}
%\addbibresource{lit.bib}
\bibliography{../lit}

\end{document}
